#!/usr/bin/perl

use warnings;
use strict;
use Error qw(:try);
use File::Basename;
use Cwd qw(getcwd realpath);

my $REPO = getcwd;

$ENV{DEBIAN_VERSION} = '';

my $DEST;
if (not $ENV{DESTINATION_DIR}) {
    $DEST =  "$REPO/debs-ppa";
} else {
    my $dest = $ENV{DESTINATION_DIR};
    if ($dest =~ m{^/}) {
        $DEST = $dest;
    } else {
        $DEST = "$REPO/" . $dest;
    }

    print "package files will be availabe in $DEST\n";
}

unless (-d $DEST) {
    print "Creating $DEST\n";
    mkdir $DEST or die "Cannot create $DEST: $!"
}


my $TMPDIR = "/tmp/zentyal-package-$$";

my $cwd;
my $dist = $ARGV[1];
unless ($dist) {
    $dist = 'lucid';
}
my $version = $ARGV[2];
unless ($version) {
    $version = 'trunk';
}
my $svnRevision = $ARGV[3];
my $pkgVersion;
my $appendDebianVersion = $ENV{'DEBIAN_VERSION'};
defined($appendDebianVersion) or $appendDebianVersion = '';

my $KEY_ID = $ENV{KEY_ID};
my $SOURCE_BUILD = $ENV{SOURCE_BUILD};

sub create_tmp
{
   if ( -d $TMPDIR) {
        system("rm -rf $TMPDIR/*");
   } else {
        mkdir $TMPDIR  or
            die "Cannot create temporal directory $DEST: $!";
   }
}

sub scm_export
{
    my ($dir, $tmpdir) = @_;

    # svn
    if (-d "$dir/.svn") {
        svn_export($dir, $tmpdir);
    # git
    } elsif (-d "$dir/.git") {
        git_export($dir, $tmpdir);
    # git-svn
    } elsif (-d "$dir/../../.git") {
        git_export($dir, $tmpdir);
    } else {
        system("cp -r $dir $tmpdir");
    }
}

sub svn_export
{
    my ($dir, $tmpdir) = @_;

    system("svn export $dir $tmpdir") and die "svn export failed";
}

sub git_export
{
    my ($dir, $tmpdir) = @_;
    
    chdir($dir);
    my $branch = `git status | head -1 | cut -d' ' -f4`;
    chomp($branch);
    mkdir $tmpdir or
        die "Cannot create temporla directory for git export $tmpdir :$!";
    system("git archive --format=tar $branch $dir | tar x -C $tmpdir");
    system("mv $tmpdir/$dir/* $tmpdir");
    system("rm -rf $tmpdir/$dir");
}

sub get_pkg_and_version
{
    open(my $fd, "configure.ac") or die "couldn't open configure.ac";

    my @file = <$fd>;
    close($fd);
    my $line = $file[0];
    my ($pkg, $version) = $line =~ m/\[(.*)\].*\[(.*)\]/;
    $pkg = lc $pkg;
    if ($svnRevision) {
        shift @file;
        $line =~ s/\[(.*)\].*\[(.*)\]/[$1], [$2~svn$svnRevision]/;
        my @newFile = ($line, @file);
        open (my $fd, ">configure.ac") or die "couldn't open configure.ac to write";
        print $fd @newFile;
        close($fd);
        $version = "$version~svn$svnRevision";
    }
    $pkgVersion = $version;
    return ($pkg, $version);
}

sub make_dist
{
    my ($tmpdir) = @_;

    chdir ($tmpdir);
    my ($name, $version) = get_pkg_and_version();
    system("./autogen.sh") and die "autogen failed";
    system("./configure --disable-runtime-tests") and die "configure failed";
    system("make dist") and die "make dist failed";

    my $file = `ls *.tar.gz`;
    chomp($file);

    my $debname = "${name}_${version}.orig.tar.gz";
    system("mv $file ../$debname\n") and die "coulnd't move tarball";

    return ($debname, "${name}-${version}");
}

sub untar
{
    my ($file) = @_;

    chdir ("..");
    system("tar xzvf $file") and "couldn't untar tarball";
}

sub export_debian
{
    my ($svndir, $destdir, $package) = @_;

    system("rm -rf $destdir/debian") if (-d "$destdir/debian");

    my $dir = $REPO;
    my $source = "$dir/$package/debian/$dist/";
    if (-d "$source/.svn") {
        system("svn export $source $destdir/debian")
            and die "couldn't export debian/$dist dir";
    } else {
        # FIXME: use git archive to avoid copying not checked in files
        system("cp -r $source $destdir/debian")
            and die "couldn't copy debian dir";
    }
}

sub add_changelog_entry
{
    my ($dir) = @_;
    chdir($dir);

    my ($version) = $dir =~ m/.*-(.*)/;

    system("dch -b -v '$version${appendDebianVersion}' -D 'lucid' --force-distribution 'New upstream release'");
}

sub build_package
{
    my ($dir) = @_;

    chdir($dir);

    my $cmd= "dpkg-buildpackage -rfakeroot";
    if ($KEY_ID) {
        $cmd .= " -k$KEY_ID";
    } else {
        $cmd .= ' -us -uc';
    }

    if ($SOURCE_BUILD) {
        $cmd .= ' -S';
    }

    system($cmd)
         and die "couldn't create package";
}

sub copy_to_dest
{
    my ($dir) = @_;

    system("cp ../*.* $DEST") and "couldn't copy to repository";
}

sub generate_rep
{
    chdir ($DEST);

    system("apt-ftparchive packages . > Packages")
                                and die "couldn't generate pkg";
    system("gzip -f Packages");
    system("apt-ftparchive sources . > Sources")
                                and die "couldn't generate src";
    system("gzip -f Sources");
}

sub clean
{
    system ("rm -rf $TMPDIR");
    chdir $cwd;
}

sub packageIt
{
    my ($package) = @_;

    $cwd = getcwd;

    my ($dir, $exportDir);

    unless (defined $package) {
        $package = basename($cwd);
        unless (-f 'configure.ac') {
            die "not in a package directory";
        }
        chdir '..';
        $REPO = getcwd;
    }

    if ($package eq 'all') {
        my @packages;

        foreach my $pkg (<*>) {
            if (-d "$pkg") {
                push(@packages, $pkg);
            }
        }
        foreach my $pkg (@packages) {
            print "Packaging $pkg...\n";
            system("$0 $pkg");
        }
        exit;
    } else {
        $dir = "$REPO/$package";
    }

    $exportDir = "$TMPDIR/$package";

    die "package no exists" unless (-e $dir);

    scm_export($dir, $exportDir);
    my ($tarball, $untardir) = make_dist($exportDir);
    untar($tarball);
    $untardir = "$TMPDIR/$untardir";

    export_debian($dir, $untardir, $package);

    add_changelog_entry($untardir);

    build_package($untardir);

    copy_to_dest($untardir);

    generate_rep();
}

try {
    create_tmp();
    packageIt($ARGV[0]);
    clean();
} otherwise {
    my $ex = shift;
    print $ex;
} finally {
    clean();
};

<chapter id="ch-examplemod">

  <title>How to create a module</title>

  <section id="sect-long-way">

    <title>Long way to create a small module</title>

    <simplesect>

      <para>Once you've seen the eBox internals, we are going to apply all
      the knowledge explained in the previous chapters creating a module
      from scratch. The first thing to do is choose a network service that
      you want to integrate into eBox. In our case we've chosen the Network
      Time Protocol server because it is one of the most simple that exist in
      eBox. Our module will provide eBox these features:</para>

      <itemizedlist>
        <listitem>
          <para>Date and time synchronization with an external server.</para>
        </listitem>

        <listitem>
          <para>Let clients synchronize their time and date with
          eBox.</para>
        </listitem>
      </itemizedlist>

      <para>And these are the steps we are going to follow in the development fo
      the module:</para>

      <itemizedlist>
        <listitem>
          <para>Study the NTP server and its features.</para>
        </listitem>

        <listitem>
          <para>Create a new module from the module template.</para>
        </listitem>

        <listitem>
          <para>Define and implement an API to manage its configuration.</para>
        </listitem>

        <listitem>
          <para>Develop CGIs and mason templates.</para>
        </listitem>

        <listitem>
          <para>Make our module show up in the eBox menu and in the summary
          page.</para>
        </listitem>

        <listitem>
          <para>Generate the configuration files and control the execution of the
          daemon.</para>
        </listitem>

        <listitem>
          <para>Establish custom rules in the firewall that let our module
          work.</para>
        </listitem>
      </itemizedlist>

    </simplesect>
    
    <section id='sect-example-define'>
      <title>Studying the NTP service and its features</title>

      <para>We've decided to develop this module using the ntp server from <ulink
      url='http://www.ntp.org'>www.ntp.org</ulink>. Debian includes packages for
      the server so we are going to use two of them:
      <emphasis>ntp-server</emphasis> to provide the time synchronization service
      to clients and <emphasis>ntpdate</emphasis> to make synchronization queries
      to external servers.</para>

      <para>After choosing the software we have to study how it works, its
      configuration files and the configurable parameters within them. With all
      this information we will be able to choose what degree of control the user
      of our module will have. We'll try to strike a balance between flexibility
      in the configuration and ease of use.</para>

      <para>For the module we are developing we only need to tune some of the
      parameters contained in the <filename>/etc/ntp.conf</filename> file,
      which holds the configuration for the ntp daemon. Of all the possible
      configuration options contained in that file, we are only interested in
      two:</para>

      <itemizedlist>
        <listitem>
          <para>The list of ntp servers we are going to use to synchronize our
          date and time. This can be achieved by adding lines like the following
          as many times as necessary to the configuration file:</para>

          <programlisting> <![CDATA[ server ntp_server_ip ]]>
          </programlisting>
        </listitem>

        <listitem>
          <para>The ability to act as an NTP server for clients in our network.
          This is done using the <varname>server</varname> attribute, as seen
          above, with an special IP address:</para>

          <programlisting> <![CDATA[ server 127.127.1.0 ]]> </programlisting>
        </listitem>
      </itemizedlist>

      <para>The NTP server has more configuration options, but we have
      decided to leave them with sane default values that are transparent to
      the user. We will concentrate on those features that will be generally
      most interesting to our users.</para>

      <para>We will also add the possibility for the user to manually change
      the system time and date and the time zone, in case there is no
      possibility to synchronize the time with external NTP servers.</para>

      <para>Time and date modification is easily done using the
      <command>/bin/date</command> command.</para>

      <para>Time zone configuration is easy too.
      <filename>/etc/localtime</filename> is a symbolic link that points
      to a file named after the location we are in. All possible timezones
      are stored under the <filename>/usr/share/zoneinfo/</filename>
      directory. Each location is stored inside its continent,
      so if our time zone is <emphasis>Madrid/Europe</emphasis>,
      then <filename>/etc/localtime</filename>must point to
      <filename>/usr/share/zoneinfo/Europe/Madrid</filename>. The
      operation of modifying the time zone is as simple as changing the
      <filename>/etc/localtime</filename> symlink.</para>

    </section>

    <section id='sect-example-module-bootstrap'>
      <title>Create a new module from the module template.</title>

      <para>As we have seen above, eBox modules have a complex directory
      structure that can be tedious to set up. Because of that, a module
      template is provided inside the tools directory in the base ebox
      module. This template provides a basic skeleton for an eBox module and
      can be cloned to create a new one. Note that you should replace the
      string modulename with your module name. </para>

      <para>eBox uses <command>autoconf</command> and
      <command>automake</command> for module configuration and
      installation. The files <filename>autogen.sh</filename>,
      <filename>configure.ac</filename> and <filename>Makefile.am</filename>
      contain the basic autotools configuration for a standard module and are
      also included in the template. The template also provides a
      <filename>m4/ebox.m4</filename> file, used by modules to detect the
      current eBox installation paths. </para>

      <para>The <ulink
      url="http://www.gnu.org/software/autoconf/manual/">Autoconf</ulink>
      and <ulink
      url="http://www.gnu.org/software/automake/manual/">Automake</ulink>
      manuals are the best autotools reference.</para>

    </section>

    <section id='sect-example-api'>
      <title>Defining and implementing the API</title>

      <para>At this point we should have gained a good degree of familiarity
      with the network service we are going to work with. We should also
      know what features will be exposed to our future users. In addition
      we have a template to use as a base for our module. The next step
      is to define the API for our module's backend. We must define which
      methods will be needed to let the rest of the modules read and write
      all the configuration options and to manage the daemon: start, stop,
      etc...</para>

      <para>The backend of our module is going to be in the
      <classname>EBox::NTP</classname> class. It will inherit from
      <classname>EBox::GConfModule</classname> and it will contain all the
      methods that conform the NTP API. This is its constructor:</para>

      <example>
        <title><classname>EBox::NTP</classname> constructor</title>
        <programlisting><![CDATA[sub _create 
        {
        my $class = shift;
        my $self = $class->SUPER::_create(name => 'ntp', 
        domain => 'ebox-ntp',
        @_);
        bless($self, $class);
        return $self;
        }]]></programlisting>
      </example>

      <para>After the analysis performed in the previous
      section we can define the following methods in
      <classname>EBox::NTP</classname>(remember that we use a leading
      underscore for private method names):</para>

      <itemizedlist>
        <listitem>
          <para>setService</para>
        </listitem>
        <listitem>
          <para>service</para>
        </listitem>
        <listitem>
          <para>setSynchronized</para>
        </listitem>
        <listitem>
          <para>synchronized</para>
        </listitem>
        <listitem>
          <para>setServers</para>
        </listitem>
        <listitem>
          <para>servers</para>
        </listitem>
        <listitem>
          <para>setNewData</para>
        </listitem>
        <listitem>
          <para>setNewTimeZone</para>
        </listitem>
        <listitem>
          <para>_restartAllServices</para>
        </listitem>
      </itemizedlist>

      <variablelist>
        
        <varlistentry>
          <term><methodname>setService</methodname></term>
          <listitem>

            <para>This method gets a boolean argument that enables or disables the
            NTP service, which will allows clients in the local network
            synchronize their time and date with eBox.</para>

            <para>Here is its implementation:</para>
            
            <example>
              <title>Enabling the NTP server</title>
              <programlisting><![CDATA[sub setService 
              {
              my ($self, $active) = @_;
              if ($active xor $self->service) {
              $self->set_bool('active', $active);
              }
              } ]]> </programlisting>
            </example>

            <para>First we read the <parameter>active</parameter> argument
            and then we use the <methodname>service</methodname> method
            to find out if the server is currently enabled. Only if the
            new value is different than the old one we go on to set
            the <parameter>active</parameter> gconf key, by calling
            <methodname>set_bool</methodname>.</para>

          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>service</methodname></term>
          <listitem>

            <para>This method returns whether the NTP server is currently
            enabled or not. Its implementation is trivial, all we need is
            to fetch the <parameter>active</parameter> gconf key and return
            it:</para>

            <example>
              <title>Reading the state of the NTP server</title>
              <programlisting><![CDATA[sub service 
              {
              my $self = shift;
              return $self->getbool('active');
              } ]]> </programlisting>
            </example>

          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>setSynchronized</methodname></term>
          <listitem>

            <para>This method receives a boolean parameter that decides
            whether eBox will synchronize its date and time with external
            NTP servers. As you can see, its implementation is similar
            to <methodname>setService</methodname>, we just use the
            <parameter>synchronized</parameter> gconf key instead:</para>

            <example>
              <title>Enabling the external NTP synchronization</title>
              <programlisting><![CDATA[sub setSynchronized # (synchronized)
              {
              my ($self, $synchronized) = @_;

              if ($synchronized xor $self->synchronized) {
              $self->set_bool('synchronized', $synchronized);
              }
              } ]]> </programlisting>
            </example>

          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>synchronized</methodname></term>
          <listitem>

            <para>This method returns the value of the
            <parameter>synchronized</parameter> gconf key.
            Its implementation is quite simple and similar to
            <methodname>service</methodname>.</para>

            <example>
              <title>Fetching the configuration for external
              synchronization</title>

              <programlisting><![CDATA[sub synchronized 
              { 
              my $self = shift;
              return $self->getbool('synchronized');
              } ]]> </programlisting>
            </example>

          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>setServers</methodname></term>
          <listitem>

            <para>This allows us to store the names of the ntp servers we
            will use to synchronize our time and date in the gconf database.
            Its implementation checks whether an IP address or a domain name
            were introduced and checks the syntax of the value accordingly.
            If the syntax is correct the servers will be stored in the
            gconf database calling the <methodname>set_string</methodname>
            method. In addition to that, we won't let the user set a
            secondary server if no primary server has been set, and the
            same for the third server. Let's see part <footnote><para>The
            complete implementation can be found in the subversion
            repository</para></footnote>of its implementation:</para>

            <example>
              <title>Setting the external NTP servers</title>
              <programlisting><![CDATA[sub setServers # (server1, server2, server3) 
              {
              my ($self, $s1, $s2, $s3) = @_;

              if ($s1 =~ /^(\d{1,3}\.){3}\d{1,3}$/) {
              checkIP($s1, __("primary server IP address"));
              $self->set_string('server1', $s1);
              } else {
              checkDomainName($s1, __("primary server name "));
              $self->set_string('server1', $s1);
              }

              if (defined($s2) and ($s2 ne "")) {
              if ($s2 =~ /^(\d{1,3}\.){3}\d{1,3}$/) {
              checkIP($s2, __("secondary server IP address"));
              $self->set_string('server2', $s2);
              } else {

              ...
              ]]> </programlisting>
            </example>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>servers</methodname></term>
          <listitem>

            <para>It returns an array that contains the NTP external
            servers stored in gconf:</para>

            <example>
              <title>Getting the list of external NTP servers</title>
              <programlisting><![CDATA[sub servers 
              {
              my $self = shift;
              my @servers;
              @servers = ($self->get_string('server1'),
              $self->get_string('server2'),
              $self->get_string('server3'));

              return @servers;
              } ]]> </programlisting>
            </example>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><methodname>setNewDate</methodname></term>
          <listitem>

            <para>This method changes the system's date and time. This is its
            implementation:</para>
            
            <example>
              <title>Setting a new system time and date</title>
              <programlisting><![CDATA[sub setNewDate # (day, month, year, hour, minute, second)
              {
              my ($self, $day, $month, $year, $hour, $min, $sec) = @_;

              my $newdate = "$year-$month-$day $hour:$min:$sec";
              my $command = "/bin/date --set \"$newdate\"";
              root($command);

              $self->_restartAllServices;
              } ]]> </programlisting>
            </example>

            <para>We receive as arguments every piece of data necessary to set the
            time and date in the system: day, month, year, hour, minutes and
            seconds.</para>

            <para>We build the complete command in the
            <varname>command</varname> variable and a call is made to the
            <function>root</function> function that executes it. This
            command must be run as root using <command>sudo</command>, that's
            why we don't run it directly.</para>

            <para>When the system time changes, some system services and eBox
            modules need to be restarted. This is implemented in the
            <methodname>_restartAllServices</methodname> method seen in <xref
            linkend='ex-ntp-restart-all'/>.</para>
          </listitem> 
        </varlistentry>

        <varlistentry>
          <term><methodname>setNewTimeZone</methodname></term>
          <listitem>
            
            <para>Along with the time and date, the time zone may be changed too.
            For this purpose we implemented this method:</para>

            <example>
              <title>Setting a new time zone</title>
              <programlisting><![CDATA[sub setNewTimeZone # (continent, country)
              {
              my ($self, $continent, $country) = @_;

              my $command = "ln -s /usr/share/zoneinfo/$continent/$country" .
              " /etc/localtime";
              $self->set_string('continent', $continent);
              $self->set_string('country', $country);
              root("rm /etc/localtime");
              root($command);
              $self->_restartAllServices;
              } ]]></programlisting>
            </example>

            <para>It gets two arguments: <parameter>continent</parameter>
            and <parameter>country</parameter>. We use them to redo
            the symbolic link in <filename>/etc/localtime</filename>
            so that it points to the new time zone. For example,
            if the two arguments are <literal>Africa</literal> and
            <literal>Africa</literal>, <filename>/etc/localtime</filename>
            will be changed so that it points to
            <filename>/usr/share/zoneinfo/Africa/Dakar</filename>.</para>

            <para>We store both arguments in gconf too, making to calls to
            <methodname>set_string</methodname>. When the time zone has
            been changed some eBox modules and the system log services are
            restarted so that they don't run with the wrong time.</para>

          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>_restartAllServices</methodname></term>
          <listitem>

            <para>Operations that change the system's time and date may leave some
            parts of the system in an inconsistent state. To avoid having eBox
            modules and system log services with a time shift we'll write a
            method that will restart all those services so that they get the new
            time and date. Here it goes:</para>

            <example id='ex-ntp-restart-all'>
              <title>Restarting eBox modules and system services</title>
              <programlisting> <![CDATA[sub _restartAllServices
              {
              my $self = shift;
              my $global = EBox::Global->getInstance();
              my @names = grep(!/^network$/, @{$global->modNames});
              @names = grep(!/^firewall$/, @names);
              my $log = $global->logger;
              my $failed = "";
              $log->info("Restarting all modules");
              
              foreach my $name (@names) {
              my $mod = $global->modInstance($name);
              try {
              $mod->restartService();
              } catch EBox::Exceptions::Internal with {
              $failed .= "$name ";
              };
              }
              
              if ($failed ne "") {
              throw EBox::Exceptions::Internal("The following modules ".
              "failed while being restarted, their state is ".
              "unknown: $failed");
              }

              $log->info("Restarting system logs");
              try {
              root("/etc/init.d/sysklogd restart");
              root("/etc/init.d/klogd restart");
              root("/etc/init.d/cron restart");
              } catch EBox::Exceptions::Internal with {
              };
              } ]]> </programlisting>
            </example>

            <para>First we get an <classname>EBox::Global</classname>
            instance that will build instances of every eBox module.
            We restart all modules except <emphasis>network</emphasis>
            and <emphasis>firewall</emphasis>, catching any exception
            that may be thrown while restarting them. Then we manually
            restart the system daemons: <emphasis>sysklogd</emphasis>,
            <emphasis>klogd</emphasis> and <emphasis>crond</emphasis>.
            Doing this requires root privileges so we invoke the
            <function>root</function> function.</para>

          </listitem>
        </varlistentry>
      </variablelist>

    </section>

    <section id='sect-example-cgis'>
      <title>Creating CGIs and templates</title>

      <para>After designing and implementing the API, it is time to create
      the layer that will interact with it: CGIs and mason templates. As
      you saw in <xref linkend='sect-example-define'/>, this module is
      going to answer NTP queries for clients in the local network. The
      API that enables and disables this service was implemented in <xref
      linkend='sect-example-api'/>. We will now create two CGIs and a mason
      template that will use these methods to give the user an interface for
      this feature:</para>

      <para>The two CGIs are <classname>EBox::CGI::NTP::Index</classname> and
      <classname>EBox::CGI::NTP::Enable</classname>, the template is called
      <filename>ntp/index.mas</filename>.</para>

      <para>Our first CGI is <classname>EBox::CGI::NTP::Index</classname>.
      It inherits from <classname>EBox::CGI::ClientBase</classname> and
      implements a constructor that sets the title for our page and the name
      of the template associated to this CGI. This is the constructor:</para>

      <example> 
        <title>Constructor for <classname>EBox::CGI::NTP::Index</classname>
        </title>
        <programlisting><![CDATA[package EBox::CGI::NTP::Index;

        use strict;
        use warnings;

        use base 'EBox::CGI::ClientBase';

        use EBox::Global;
        use EBox::Gettext;

        sub new {
        my $class = shift;
        my $self = $class->SUPER::new('title'    => NTP,
        'template' => 'ntp/index.mas', @_);

        $self->{domain} = "ebox-ntp";
        bless($self, $class);
        return $self;
        } ]]> </programlisting>
      </example>

      <para>A noteworthy detail is the fact that the title string in this
      CGI is not translatable, and thus we haven't followed the instructions
      in <xref linkend='sect-i18n-developers'/> for i18n. If the title was
      translatable we would have followed those instructions.</para>

      <para>We are now ready to implement the
      <methodname>_process</methodname> method, which reads the current
      configuration for the NTP server and feeds it to the mason
      template.</para>

      <example>
        <title>Feeding the configuration of the NTP server to the mason
        template</title>

        <programlisting><![CDATA[sub _process
        {
        my $self = shift;
        my $ntp = EBox::Global->modInstance('ntp');

        my @array = ();
        my $active = 'no';

        if ($ntp->service()) {
        $active = 'yes';
        }

        push (@array, 'active'     => $active);
        $self->{params} = \@array;
        }]]></programlisting>
      </example>

      <para>You can see that the first thing we do is create an instance of
      our module (ntp) using <classname>EBox::Global</classname>. We use this
      instance to invoke the <methodname>service</methodname> method, which
      returns the configuration of the server and we pass it to the mason
      template placing it in the <structfield>param</structfield> attribute
      of the CGI. If the mason template needed more arguments we would just add
      them to the <varname>array</varname> variable.</para>

      <para>This CGI we just implemented, along with its mason template,
      shows the current configuration for the NTP server. We will now
      implement the CGI that will receive a new configuration from the user
      and will tell the backend to change it.</para>

      <example>
        <title>CGI to enable and disable the NTP server</title>
        <programlisting><![CDATA[package EBox::CGI::NTP::Enable;

        use strict;
        use warnings;

        use base 'EBox::CGI::ClientBase';

        use EBox::Global;
        use EBox::Gettext;

        sub new 
        {
        my $class = shift;
        my $self = $class->SUPER::new('title' => 'NTP', @_);
        $self->{redirect} = "NTP/Index";
        $self->{domain} = "ebox-ntp";
        bless($self, $class);

        return $self;
        }

        sub _process
        {
        my $self = shift;
        my $ntp= EBox::Global->modInstance('ntp');

        $self->_requireParam('active', __('module status'));
        $ntp->setService(($self->param('active') eq 'yes'));
        }

        1; ]]> </programlisting>
      </example>

      <para>Its implementation is quite simple, only a couple of details are
      noteworthy.</para>

      <para>First, the constructor sets the
      <structfield>redirect</structfield> attribute to
      <literal>NTP/Index</literal>. This will make the browser invoke that
      CGI after setting the configuration so that the value shown to the user
      is refreshed.</para>

      <para>Finally, we use the <methodname>setService</methodname> method,
      and we pass it a boolean argument that results from the reading of the
      <parameter>active</parameter> parameter from the HTTP request. HTTP
      parameters are fetched by invoking the <methodname>param</methodname>
      method from the parent class.</para>

      <para>Next we are going to create the mason template that will
      display the configuration and the form to change it. This is an
      special case, since most eBox modules will need to enable/disable
      network services. A common way of doing this is provided by the
      <filename>enable.mas</filename> mason template, which is part of the
      basic framework.</para>

      <para>It is very easy to use it. We create a template that receives an
      argument with the current configuration of the server. As explained
      in <xref linkend='sect-mason'/> we can include an external template
      by writing: 
      <programlisting><![CDATA[<& template.mas, @arguments &>]]></programlisting>.
      We are going to include <filename>enable.mas</filename> and we give it two
      arguments, the title and the current configuration of the NTP server. It
      looks like this:</para>

      <example> 
        <title>Mason template for enabling the NTP server</title> 
        <programlisting><![CDATA[<%args> $active </%args>
        <%init> use EBox::Gettext; </%init>

        <div class='ntpnew'>
        <br />
        <& enable.mas, title => __('Enable the local NTP server'),
        active => $active &>
        </div>
        ]]></programlisting>
      </example>

      <para>Using <filename>enable.mas</filename> requires that
      the CGI that enables or disables the service be called
      <classname>Enable</classname>, since that is hard-coded into
      <filename>enable.mas</filename>. If you take another look at the CGI
      we implemented for this purpose, you'll see that its classname is
      <classname>EBox::CGI::NTP::Enable</classname>, just as required.</para>

      <para>We are now missing the CGIs that change the time zone, the time
      and date, and set the external NTP servers. These CGIs and templates
      are quite simple, it you want to see their source code you can check
      the subversion repository, their code will not be shown here, we'll
      limit ourselves to a quick overview of the files involved and their
      relationships.</para>

      <para>Two CGIs handle the time zone changing feature:</para>

      <itemizedlist>
        <listitem>
          <para><classname>Timezone</classname> uses a mason template
          (<filename>timezone.mas</filename>) to display the current timezone
          configuration.</para>
        </listitem>
        <listitem>

          <para><classname>ChangeTimeZone</classname> receives
          the new timezone from the web browser and invokes the
          <methodname>SetNewTimeZone</methodname>.</para>
        </listitem>
      </itemizedlist>

      <para>There is one more detail about the
      <classname>TimeZone</classname> CGI. It sends the current country and
      continent to the mason template, but it also sends a list with all
      possible continents and a hash that links each continents with the
      list of countries it contains. All this information is read from the
      <filename>/usr/share/zoneinfo/zone.tab</filename> file.</para>

      <para>Finally, our module provides two ways to establish the system's
      time and date: manually and synchronizing with external NTP servers.
      Each of these two methods excludes the other one (the user can only
      use one of the two methods). The <classname>Datetime</classname> CGI
      displays the information about the current time and date and the
      configuration of the external NTP servers stored in gconf. Two CGIs let
      the user change the settings shown in <classname>Datetime</classname>:
      <classname>Synch</classname> enables the synchronization against
      external NTP servers and <classname>ChangeDate</classname> changes the
      time and date manually.</para>

      <para>We just said that only one of the two methods may be used at
      the same time. This is enforced by the mason templates, and we are
      going to see how it's done. The <filename>datetime.mas</filename>
      template gets its arguments from the <classname>Datetime</classname>
      CGI, it includes the template <filename>synch.mas</filename>
      which lets the user choose whether he wants to set the time
      manually or use external NTP servers. Then, depending on the
      current configuration it loads the NTP server selection template
      (<filename>servers.mas</filename>) or the manual time and date
      configuration template (<filename>date.mas</filename>).</para>

      <example>
        <title><filename>datetime.mas</filename> template</title>
        <programlisting><![CDATA[<& /ntp/synch.mas, title => __('Synchronize with external NTP servers'),
        synchronized => $synchronized &>

        % if ($synchronized eq 'yes') {
        <& /ntp/servers.mas, title => __('External NTP servers'), servers => \@servers
        &>
        % }

        % if ($synchronized eq 'no') {
        <& /ntp/date.mas, title => __('Change Date and Time'), date => \@date &>
        % }]]></programlisting>
      </example>

      <para><filename>synch.mas</filename>, <filename>server.mas</filename>
      and <filename>date.mas</filename> just display the information that
      <filename>datetime.mas</filename> sends them as arguments.</para>
    </section>

    <section id='sect-example-menu'>
      <title>Showing the menu and the Summary page</title>

      <para>We are already in the final steps in the development of our
      module. Now we are going to add a new section to the eBox menu that
      will let the user access the user interface of our module and a section
      to the summary page with information about the ntp module.</para>

      <para>Adding a new section to the menu is as simple as
      implementing the <methodname>menu</methodname> method in our
      <classname>EBox::NTP</classname> class. This method gets an instance
      of <classname>EBox::Menu::Root</classname> to which we will add
      a new NTP section with several items: <quote>NTP Server</quote>,
      <quote>Date/Time</quote> and <quote>Time zone</quote>. Here is the
      <methodname>menu</methodname> method:</para>

      <example>
        <title>Adding entries to the eBox menu</title>
        <programlisting><![CDATA[sub menu
        {
        my ($self, $root) = @_;
        my $folder = new EBox::Menu::Folder('name' => 'NTP',
        'text' => __('NTP'));

        $folder->add(new EBox::Menu::Item('url' => 'NTP/Index',
        'text' => __('NTP server')));
        $folder->add(new EBox::Menu::Item('url' => 'NTP/Datetime',
        'text' => __('Date/time')));
        $folder->add(new EBox::Menu::Item('url' => 'NTP/Timezone',
        'text' => __('Time zone')));
        $root->add($folder);
        }]]></programlisting>
      </example>

      <para>As you saw in <xref linkend='sect-menu'/>, a new section is
      created with an instance of <classname>EBox::Menu::Folder</classname>,
      which needs to be given a name.</para>

      <para>The we add to it instances of
      <classname>EBox::Menu::Item</classname> which needs a name and a URL
      (as we explained in <xref linkend='sect-cgi'/>, we only need to specify
      <quote>NTP/Index</quote>, not the whole path).</para>

      <para>The NTP module is not going to have its own section in the
      summary page as there is not much information to display. We'll just
      add an entry in the status table at top of that page. For that we are going
      to implement the <methodname>statusSummary</methodname> method in
      <classname>EBox::NTP</classname>:</para>

      <example>
        <title><methodname>statusSummary</methodname> in 
        <classname>EBox::NTP</classname></title>

        <programlisting><![CDATA[sub statusSummary
        {
        my $self = shift;
        return new EBox::Summary::Status('ntp', __('NTP local server'),
        $self->isRunning, $self->service);
        }]]></programlisting>
      </example>

    </section>

    <section id='sect-example-daemon'>
      <title>Generating config files and managing the NTP server</title>

      <para>Let's see how you can use mason templates to generate the config
      file for the NTP server. In <xref linkend='sect-example-define'/>
      we saw that the NTP server reads all its configuration from the
      <filename>/etc/ntp.conf</filename> file. We'll use the same system we
      use to generate HTML for this file.</para>

      <para>This part of the module belongs in the backend, so
      all the methods needed to implemented will be placed in
      <classname>EBox::NTP</classname>.</para>

      <para>We have created a private method called
      <methodname>_setNTPConf</methodname> which will be invoked every time
      we need to generate the config file. Here it is:</para>

      <example>
        <title> Generating the <filename>/etc/ntp.conf</filename> config
        file</title>

        <programlisting><![CDATA[sub _setNTPConf
        {
        my $self = shift;
        my @array = ();
        my @servers = $self->servers;
        my $synch = 'no';
        my $active = 'no';

        ($self->synchronized) and $synch = 'yes';
        ($self->service) and $active = 'yes';

        push(@array, 'active'   => $active);
        push(@array, 'synchronized'  => $synch);
        push(@array, 'servers'  => \@servers);

        $self->writeConfFile(NTPCONFFILE, "ntp/ntp.conf.mas", \@array);
        }]]></programlisting>
      </example>

      <para>It is very simple, we just add all the arguments for the mason
      template to the <varname>array</varname> variable. Our arguments
      are:</para>

      <variablelist>
        <varlistentry>
          <term><parameter>active</parameter></term>
          <listitem>
            <para>It tells the template whether we are going to offer the NTP
            service for clients in our network or not.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><parameter>synchronized</parameter></term>
          <listitem>
            <para>It tells the template whether we are going to synchronize our
            system's time with external NTP servers.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><parameter>servers</parameter></term>
          <listitem>
            <para>It's an array with the list of external NTP servers.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>After building the array with the arguments we call
      <methodname>writeConfFile</methodname>, which generates the configuration
      file with proper permissions and needs these arguments:</para>
      
      <itemizedlist>
        <listitem>
          <para>The absolute path to the configuration file. In our case it is the
          <constant>NTPCONFFILE</constant> constant, which is defined in the
          beginning of our module: </para>
          <programlisting><![CDATA[use constant NTPCONFFILE => "/etc/ntp.conf";]]></programlisting>
        </listitem>

        <listitem>
          <para>The path to the mason template that generates the file.</para>
        </listitem>

        <listitem>
          <para>An array with the arguments for the template.</para>
        </listitem>
      </itemizedlist>

      <para>And now let's see the template. We decided to leave some of the
      values in the config file with fixed values, other values are dynamic and
      are generated based on the arguments received:</para>

      <example>
        <title>Template to generate
        <filename>/etc/ntp.conf</filename></title>
        <programlisting><![CDATA[<%args>
        $active
        $synchronized
        @servers
        </%args>
        # /etc/ntp.conf, configuration for ntpd
        # Generated by EBox

        driftfile /var/lib/ntp/ntp.drift
        statsdir /var/log/ntpstats/

        % if ($synchronized eq 'yes') {
        %       if ($servers[0]) {
        server <% $servers[0] %>
        %       }
        %       if ($servers[1]) {
        server <% $servers[1] %>
        %       }
        %       if ($servers[2]) {
        server <% $servers[2] %>
        %       }
        % }
        % if ($active eq 'yes') {
        server 127.127.1.0
        % }
        fudge 127.127.1.0 stratum 13

        restrict default kod notrap nomodify nopeer noquery

        restrict 127.0.0.1 nomodify]]></programlisting>
      </example>

      <para>The only thing left is the code to manage the ntp
      daemon. We have to implement several methods, the first is an
      abstract method defined in <classname>EBox::Module</classname>:
      <methodname>_regenConfig</methodname>. It is invoked when services
      are restarted or when a new configuration for a module is saved.
      It has to generate the config file, using the already seen
      <methodname>_setNTPConf</methodname> method. Let's see it:</para>

      <example>
        <title><methodname>_regenConfig</methodname> method</title>
        <programlisting><![CDATA[sub _regenConfig
        {
        my $self = shift;

        $self->_setNTPConf;
        $self->_doDaemon();
        }]]></programlisting>
      </example>

      <para>Besides invoking <methodname>_setNTPConf</methodname>,
      it needs to restart the daemon, it does so by calling
      a private method: <methodname>_doDaemon</methodname>.
      Together with methods <methodname>_daemon</methodname>,
      <methodname>_stopService</methodname>, and
      <methodname>isRunning</methodname>, <methodname>_doDaemon</methodname>
      performs the management of the daemon. Let's see them one by
      one:</para>

      <example>
        <title>NTP daemon management method</title>
        <programlisting><![CDATA[sub _doDaemon
        {
        my $self = shift;
        my $logger = EBox::Global->logger;

        if (($self->service or $self->synchronized) and $self->isRunning) {
        $self->_daemon('stop');
        sleep 2;
        if ($self->synchronized) {
        my $exserver = $self->get_string('server1');
        try {
        root("/usr/sbin/ntpdate $exserver");
        } catch EBox::Exceptions::Internal with {
        $logger->info("Error, ntpdate could" .
        " not be started.");
        };
        }
        $self->_daemon('start');
        } elsif ($self->service or $self->synchronized) {
        if ($self->synchronized) {
        my $exserver = $self->get_string('server1');
        try {
        root("/usr/sbin/ntpdate $exserver");
        } catch EBox::Exceptions::Internal with {
        $logger->info("Error ntpdate could" .
        " not be started.");
        };
        }
        $self->_daemon('start');
        } elsif ($self->isRunning) {
        $self->_daemon('stop');
        if ($self->synchronized) {
        $self->_daemon('start');
        }
        }
        }]]></programlisting>
      </example>

      <para>This method is invoked:</para>
      
      <itemizedlist>
        <listitem>
          <para>To launch the server if it was stopped.</para>
        </listitem>
        <listitem>
          <para>To restart the server when it is running.</para>
        </listitem>
        <listitem>
          <para>To stop the server.</para>
        </listitem>
      </itemizedlist>

      <para>Depending on which case we are in it calls
      <methodname>_daemon</methodname> telling it which action we want to
      perform: start or stop. If the system date is to be synchronized
      with external servers we should try to make a manual query with the
      <command>/usr/sbin/ntpdate</command> before starting the daemon. This
      is a recommended practice before launching the ntp daemon.</para>

      <para>Let's see the <methodname>_daemon</methodname> code, which
      starts, stops or restarts the daemon directly depending on its
      argument:</para>

      <example>
        <title>Commands for starting and stopping the ntp daemon.</title>
        <programlisting><![CDATA[sub _daemon # (action)
        {
        my ($self, $action) = @_;

        if ( $action eq 'start') {
        root("start-stop-daemon --start --quiet --pidfile" .
        " /var/run/ntpd.pid --exec /usr/sbin/ntpd " .
        " -- -g -p /var/run/ntpd.pid");
        } elsif ( $action eq 'stop') {
        root("start-stop-daemon --stop --quiet --pidfile" .
        " /var/run/ntpd.pid");
        } elsif ( $action eq 'force-reload') {
        root("start-stop-daemon --stop --quiet --pidfile"
        " /var/run/ntpd.pid");
        sleep 2;
        root("start-stop-daemon --start --quiet --exec /usr/sbin/ntpd -- -g -p /var/run/ntpd.pid");
        } else {
        throw EBox::Exceptions::Internal("Bad argument: $action");
        }
        }]]></programlisting>
      </example>

      <para>There only two methods left for you to see.
      <methodname>_stopService</methodname> is defined as an abstract method by
      <classname>EBox::Module</classname>, it just stops the service.
      <methodname>isRunning</methodname> tells us whether the ntp daemon is
      currently running, it does so by checking its process id (PID).</para>

      <example>
        <title><methodname>_stopService</methodname> method.</title>
        <programlisting><![CDATA[sub _stopService
        {
        my $self = shift;

        if ($self->isRunning) {
        $self->_daemon('stop');
        }
        }
        ]]> </programlisting>
      </example>

      <example>
        <title>Telling wheter the ntp daemon is running or not.</title>
        <programlisting><![CDATA[sub isRunning
        {
        my $self = shift;
        return $self->pidFileRunning(PIDFILE);
        }
        ]]> </programlisting>
      </example>
    </section>

    <section id='sect-example-firewall'>
      <title>Setting up proper firewall rules</title>

      <para>The last step in creating this module is to let the firewall know
      about our needs, so that the ntp service works fine. If our date is set
      by querying external servers we will need to make UDP connections on
      port 123 to them. We also need to let clients connect to our 123 UDP
      port if we are going to be an NTP server. We created a private method
      called <methodname>_configureFirewall</methodname> that takes care of
      all this stuff. Here it is:</para>

      <example>
        <title>Firewall configuration</title>
        <programlisting><![CDATA[sub _configureFirewall
        {
        my $self = shift;
        my $fw = EBox::Global->modInstance('firewall');

        if ($self->synchronized) {
        $fw->addOutputRule('udp', 123);
        } else {
        $fw->removeOutputRule('udp', 123);
        }

        if ($self->service and (!defined($fw->service('ntp')))) {
        $fw->addService('ntp', 'udp', 123, 0);
        $fw->setObjectService('_global', 'ntp', 'allow');
        } elsif ( !($self->service) and defined($fw->service('ntp')) ) {
        $fw->removeService('ntp');
        }
        }]]></programlisting>
      </example>

      <para>The eBox firewall module simplifies this job providing
      methods that let us add new rules to the firewall. First of all
      we need an instance of the firewall module, as usual we use
      <classname>EBox::Global</classname> to get it. Then we add the
      output rule if we need to connect to external servers or remove
      it if we do not need to and it had been previously added. The
      methods for this are <methodname>addOutputRule</methodname> and
      <methodname>removeOutputRule</methodname>.</para>

      <para>For our NTP server, we need to register our service with
      the firewall by calling <methodname>addService</methodname>
      and then we'll allow it by default by calling
      <methodname>setObjectService</methodname>. If the NTP server feature is
      disabled we remove the ntp service from the firewall by calling
      <methodname>removeService</methodname>.</para>

    </section>
    
    <section id='sect-example-conclusion'>
      <title>Conclusion</title>

      <para>We are done, we just created an eBox module form scratch. We've
      gone through every step needed and seen what issues to watch out for.
      Now it is time to try it out and do some tests to check that it works
      as we expect. We hope this guide has been helpful and encourages you
      to contribute to making it a better platform with new modules and
      features.</para>
    </section>

  </section>

  <section id="sect-short-way">
    
    <title>Short way to create a small module</title>

  </section>

</chapter>

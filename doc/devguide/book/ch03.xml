<!-- vim: ts=2 sw=2
-->
<chapter id="ch-backend">

	<title>Module backend</title>

	<simplesect>

		<para>The eBox framework offers modules several functionalities that
		are made available through a mostly object-oriented API. Not everything
		is object-oriented, procedural interfaces have been used where it made
		sense to do so.</para>

		<para>Some of the features of the API work through inheritance,
		these usually provide a means for the module to implement standard
		functionalities like menus, the status page, configuration saving and
		revoking, etc. Some of these functionalities need to be implemented by
		the module, others are given by the framework for free, and the module
		may override or extend them.</para>

	</simplesect>

	<section id="sect-basemod">
		<title>The base module</title>

		<para>All eBox modules inherit from the
		<classname>EBox::Module</classname> class, this class defines abstract
		methods that modules may override to implement certain functionality.
		These methods are called by the framework when they are needed.</para>

		<para>Besides those abstract methods, the class implements a few
		methods, providing some basic functionality. These methods often
		follow the template method design pattern, they perform some operation
		but delegate some part of it on some abstract method that may be
		implemented by child classes.</para>

		<!-- FIXME - class diagram -->

		<para>Finally, there are a few methods that implement some common
		operations that get used in most of the modules, these are meant to be
		called by children classes when they need them. They are located in the
		<classname>EBox::Module</classname> class just for convenience.</para>

		<section id="sect-modconstructor">
			<title>Module constructor</title>

			<para>All module instances are created and cached by the
			<classname>EBox::Global</classname> class, module constructors must
			not be called directly except by <classname>EBox::Global</classname>.
			For this reason, they are named <methodname>_create</methodname>
			instead of <methodname>new</methodname>.</para>

			<para>The leading underscore in the method name is a naming
			convention, methods with such a name are meant to be used
			privately by the owner class and its ancestors, they should
			not be called directly by an unrelated class. In the case of
			the module constructor, the only class that should call it is
			<classname>EBox::Global</classname>.</para>

			<para>The <methodname>_create</methodname> method in
			<classname>EBox::Module</classname> takes two named arguments
			from the child classes. <parameter>name</parameter> is the name
			of the module, it is required; <parameter>domain</parameter> is
			the <application>gettext</application> domain for the module, it's
			optional and <quote>ebox</quote> is its default value.</para>

			<example>
				<title>Simple module constructor</title>
				<programlisting><![CDATA[sub _create
{
	my $class = shift;
	my $self = $class->SUPER::_create(name => 'dhcp',
					domain => 'ebox-dhcp',
					@_);
	bless ($self, $class);
	return $self;
}]]></programlisting>
			</example>

		</section>

	</section>

	<section id="sect-rootcmds">
		<title>Root commands</title>

		<para>The apache server under which eBox runs, and any Perl script
		that uses the eBox API run under a dedicated user id, the user is
		typically called <quote>ebox</quote>. eBox modules need to execute
		certain commands and write certain files with root privileges, this
		is done using <application>sudo</application>
                </para>


		<para>You can invoke any command using the 
                <methodname>root()</methodname>
		function in the <classname>EBox::Sudo</classname> Perl module. If the
		command fails, <methodname>root()</methodname> throws a 
		exception of type <classname>EBox::Exceptions::Sudo::Command</classname>, so make sure you catch it if it's OK for the command to
		fail or if you want to inform the user in a different
                way. In any case you can use 
                the <methodname>output</methodname>,
                <methodname>error</methodname> and
                <methodname>exitValue</methodname> exception methods
                to gather more information about the command failure. 
                In the rare cases when the sudo program itself fails the
                exception raised is of type
                <classname>EBox::Exceptions::Sudo::Wrapper</classname>
                and the last methods aren't available.
                </para>

			<example>
				<title>Using EBox::Sudo::root()</title>
				<programlisting><![CDATA[try {
  EBox::Sudo::root("/usr/bin/eject -t");
}
catch EBox::Exceptions::Sudo::Wrapper with {
  throw EBox::Exceptions::Internal("sudo program failed");
}
catch EBox::Exceptions::Sudo::Command with {
  my ($ex) = @_;
  EBox::debug("/usr/bin/eject failed. Stderr was " . (join "\n", @{ $ex->error() })) ;
  throw EBox::Exceptions::External("Cannot close CD-ROM tray. Please close it manually" );
}
]]></programlisting>
			</example>

                <para> 
                 <classname>EBox::Sudo</classname> also provides
                 wrappers for frequent used
                 commands executed with root
                 privileges. <methodname>stat</methodname> provides a
                 stat wrapper, useful to get file system information
                 for any file. If you need a more concise file
                 information you can use
                 <methodname>fileTest</methodname> to check files for
                 simples queries like does the <application>/usr/bin/test</application>
                </para>


	</section>

	<section id="sect-gconf">
		<title><classname>EBox::GConfModule</classname></title>

		<para>eBox uses GConf to store its configuration, the
		development framework provides a wrapper around the <ulink
		url='http://gtk2-perl.sourceforge.net/doc/pod/Gnome2/GConf.html'>
		original perl bindings</ulink>. GConf gives us an easy API for storing
		and retrieving typed configuration values organized hierarchically. It
		also lets us define limited schemas for certain configuration keys,
		setting their type and default values.</para>

		<!-- FIXME - example -->

		<para>The development framework defines a wrapper around the GConf API
		that provides some extra features. The wrapper is implemented as child
		class for <classname>EBox::Module</classname>, so all modules that want
		to use GConf inherit from <classname>EBox::GConfModule</classname>. Its
		children automatically get these features:</para>

		<itemizedlist>

			<listitem>

				<para>Automatic backups: the first time a key's value is changed,
				a backup of the configuration tree for the whole module is made.
				When the configuration is saved, the backup is automatically
				deleted, when the configuration changes are revoked the backup is
				automatically restored. <classname>EBox::GConfModule</classname>
				implements the <methodname>makeBackup</methodname>,
				<methodname>restoreBackup</methodname> and
				<methodname>revokeConfig</methodname> methods
				defined in <classname>EBox::Module</classname>, so
				<classname>EBox::GConfModule</classname> children do not need to
				implement them unless they have really special requirements or
				store part of their configuration outside of GConf.</para>

			</listitem>
			<listitem>

				<para>Error handling: GConf errors are handled by the wrapper
				class, it translates them into internal exceptions.</para>

			</listitem>
			<listitem>

				<para>Read-only and read-write instances: when the module is
				instantiated in read-only mode, the wrapper class uses a copy of
				the configuration to avoid seeing unsaved changes. It also prevents
				calls to methods that write to GConf.</para>

			</listitem>
			<listitem>

				<para>Namespace boundary checks: the wrapper checks all gconf
				keys used by the module to see if they are in its namespace. This
				ensures that the keys for a module are only directly read or
				written to by the module itself (as long as all modules use the
				wrapper class).</para>

			</listitem>
			<listitem>

				<para>Relative pathnames: methods in the wrapper class take both
				absolute and relative pathnames for gconf keys. The root of a
				module's namespace changes depending on the type of instance
				(read-only of read-write) and the type of key (normal or status)
				being accessed. For this reason it is best to use relative
				pathnames when calling the wrapper class methods, they translate
				the relative path to an absolute one automatically.</para>

			</listitem>
			<listitem>

				<para>Status namespace: the is certain information that's not
				given by the user and needs to be written at any time, even by
				read-only instances. This kind of information is not subject to
				configuration saving and revoking. It is status information,
				like the name servers or IP address given to the system by an
				external dhcp server. A separate namespace is provided for this
				kind of information, and again it is automatically kept out of the
				backup/save/revoke operations mentioned earlier. The methods use to
				access this namespace are identical to the usual ones, they just
				have the prefix <literal>st_</literal> in their names.</para>

			</listitem>

			<listitem>

				<para>Recursive retrieval of directories: there are two
				methods in <classname>EBox::GConfModule</classname> that
				allow easy retrievals of whole directory structures.
				<methodname>hash_from_dir</methodname> takes a directory as
				an argument and returns a hash with all the keys under it.
				<methodname>array_from_dir</methodname> takes a directory as
				an argument and returns an array of hashes as returned by
				<methodname>hash_from_dir</methodname> for each one of its
				subdirectories.</para>

			</listitem>

		</itemizedlist>

		<para>This is a list of the most important methods in
		<classname>EBox::GConfModule</classname>:</para>

		<variablelist>
			<varlistentry>
				<term><methodname>all_dirs</methodname></term>
				<listitem>

					<para>Given a key it returns all directories within.</para>
				
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>all_dirs_base</methodname></term>
				<listitem>

					<para>Given a key it returns all directories within, removing any
					leading directory component.</para>
				
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>all_entries</methodname></term>
				<listitem>

					<para>Given a key it returns all entries within. Entries are
					all those keys which are not directories, hence they contain a
					value.</para>
					
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><methodname>all_entries_base</methodname></term>
					<listitem>

					<para>Given a key it returns all entries within, removing any
					leading directory component. Entries are all those keys which are
					not directories, hence they contain a value.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>array_from_dir</methodname></term>
				<listitem>

					<para>Given a key it returns an array using a hash reference to
					contain in each element the directories under the key. Also, the
					hash contains the key <structfield>_dir</structfield> which tells
					you the directory's name.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>dir_exists</methodname></term>
				<listitem>

					<para>Given a key referencing a directory it returns
					<literal>true</literal> if it exists.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_bool</methodname></term>
				<listitem>

					<para>Returns the value of a boolean key.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_int</methodname></term>
				<listitem>

					<para>Returns the value of a integer key.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_list</methodname></term>
				<listitem>

					<para>Returns an array containing the list referenced by the
					key.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_string</methodname></term>
				<listitem>

					<para>Returns the value of a string key.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_unique_id</methodname></term>
				<listitem>

					<para>It generates a unique random identifier with a leading
					<parameter>prefix</parameter> in the root of the module's
					namespace, if <parameter>directory</parameter> is passed, it will
					be added to the path. Note that it does not create the entry, it
					just returns a unique identifier, so it is up to you to create
					the proper entry.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>hash_from_dir</methodname></term>
				<listitem>

					<para>It returns a hash containing all the entries in the
					directory referenced by the key.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>isReadOnly</methodname></term>
				<listitem>

					<para>It returns <literal>true</literal> if the current
					<classname>EBox::GConfModule</classname> instance you are
					accessing is read-only.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>makeBackup</methodname></term>
				<listitem>

					<para>It dumps your current configuration to file.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>restoreBackup</methodname></term>
				<listitem>

					<para>It restores the last backup.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>revokeConfig</methodname></term>
				<listitem>

					<para>All changes done since your first write or delete will be
					dismissed.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>set_bool</methodname></term>
				<listitem>

					<para>It sets a <parameter>key</parameter> with a boolean
					<parameter>value</parameter>.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>set_int</methodname></term>
				<listitem>

					<para>It sets a <parameter>key</parameter> with an integer
					<parameter>value</parameter>.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>set_list</methodname></term>
				<listitem>

					<para>It sets a list of
					<parameter>type</parameter><parameter>values</parameter> in
					<parameter>value</parameter>.</para>
				
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>set_string</methodname></term>
				<listitem>

					<para>It sets <parameter>values</parameter> of
					<parameter>type</parameter> in <parameter>key</parameter>.</para>

				</listitem>
			</varlistentry>
		</variablelist>
			
		<para>Let see some examples from the above functions.</para>	
		
		<example>
			<title>Setting a string key</title>
			<programlisting> <![CDATA[$self->set_string("printers/x4235/name", "fooprinter"); ]]></programlisting>
		</example>

		<example>
			<title>Setting a string list</title>
			<programlisting><![CDATA[$self->set_list('foo/foolist', 'string', ['foo', 'bar']);]]></programlisting>
		</example>

		<example>
			<title>Getting and using a unique identifier</title>
			<programlisting><![CDATA[my $id = $self->get_unique_id('p', 'printers');
$self->set_string("printers/$id/name", $name);
$self->set_bool("printers/$id/configured", undef);
		]]></programlisting>
		</example>
	</section>

	<section id="sect-ordering">
		<title>Ordering stuff</title>

		<para>The need to keep certain information ordered is fairly common
		across eBox modules. It is also common to provide reordering functions.
		An example of this are firewall rules, which need to be applied in
		a given order, and the user has to be able to change their order.
		The <classname>EBox::Order</classname> class solves just this
		problem.</para>

		<para>The idea is to give a directory to each item you want to
		keep ordered. Following the firewall example, we could have a
		<filename>rules/</filename> directory and, below it, one directory
		per rule. Each rule would get a unique identifier, and that
		would be its directory name below <filename>rules/</filename>.
		A rule with id <literal>r3561</literal> would be stored in
		<filename>rules/r3561</filename>, and below that directory we would
		store keys with each one of the rule's parameters. This is the most
		natural way of organizing items such as firewall rules, and it is with
		this organization that <classname>EBox::Order</classname> is designed
		to work.</para>

		<!-- FIXME example -->

		<para>The ordering mechanism adds one field to the
		items being ordered. Not surprisingly it is called
		<structfield>order</structfield>. To use the ordering API you have
		to create an <classname>EBox::Order</classname> instance. Its
		constructor takes to arguments: the instance of the module that owns
		the items being ordered, and the base directory where the items are
		stored.</para>

		<para><classname>EBox::Order</classname> implements these
		operations:</para>

		<variablelist>

			<varlistentry>
				<term><methodname>highest</methodname></term>
				<listitem>

					<para>Returns the highest <structfield>order</structfield> key of
					all the items.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>lowest</methodname></term>
				<listitem>

					<para>Returns the lowest <structfield>order</structfield> key of
					all the items.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>nextn</methodname></term>
				<listitem>

					<para>Given a number, returns the
					<structfield>order</structfield> key for the next item.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>prevn</methodname></term>
				<listitem>

					<para>Given a number, returns the
					<structfield>order</structfield> key for the previous
					item.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>get</methodname></term>
				<listitem>

					<para>Returns the identifier for the item whose
					<structfield>order</structfield> key equals a given
					number.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>swap</methodname></term>
				<listitem>

					<para>It finds the items whose <structfield>order</structfield>
					keys match two given numbers and swaps their values.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>list</methodname></term>
				<listitem>

					<para>Returns a reference to an array that holds the identifiers
					of all items, ordered from lowest to highest order.</para>

				</listitem>
			</varlistentry>

		</variablelist>

		<example>
			<title>Ordering firewall rules</title>

			<para>Let's see how the firewall module uses
			<classname>EBox::Order</classname> to keep its forwarding rules
			ordered. The <methodname>_fwdRulesOrder</methodname> returns the
			<classname>EBox::Order</classname> instance for the firewall
			rules:</para>

			<programlisting><![CDATA[sub _fwdRulesOrder
{
	my $self = shift;
	return new EBox::Order($self, "fwdrules");
}]]></programlisting>

			<para><filename>fwdrules</filename> is the directory that
			holds all the rules. Another private helper function is
			<methodname>_fwdRuleNumer</methodname>, it returns the order number
			for a given rule identifier:</para>

			<programlisting><![CDATA[sub _fwdRuleNumber # (rule)
{
	my ($self, $rule) = @_;
	return $self->get_int("fwdrules/$rule/order");
}]]></programlisting>

			<para>New rules are appended at the end of the list, so we find the
			highest order number and add one to it, this code is part of the
			<methodname>addFwdRule</methodname> method:</para>

			<programlisting><![CDATA[my $order = $self->_lastFwdRule() + 1;

$self->set_string("fwdrules/$id/name", $id);
$self->set_string("fwdrules/$id/action", $action);
$self->set_bool("fwdrules/$id/active", 1);
$self->set_int("fwdrules/$id/order", $order);]]></programlisting>

			<para><methodname>_lastFwdRule</methodname> is a trivial wrapper that
			returns the highest ordered number:</para>

			<programlisting><![CDATA[sub _lastFwdRule
{
	my $self = shift;
	my $order = $self->_fwdRulesOrder();
	defined($order) or return 0;
	return $order->highest;
}]]></programlisting>

			<para>Finally there are two methods to allow rule
			reordering, they are <methodname>FwdRuleUp</methodname> and
			<methodname>FwdRuleDown</methodname> (only the first one is shown
			here since they are almost identical):</para>

			<programlisting><![CDATA[sub FwdRuleUp # (rule)
{
	my ($self, $rule) = @_;
	my $order = $self->_fwdRulesOrder();
	defined($order) or return;
	my $num = $self->_fwdRuleNumber($rule);
	if ($num == 0) {
		return;
	}
	my $prev = $order->prevn($num);
	$order->swap($num, $prev);
}]]></programlisting>
		</example>

	</section>

	<section id="sect-config-and-daemons">
		<title>Controlling a daemon</title>

		<para>Besides exposing an API that allows reading and changing the
		configuration of a given service, a module's backend is in charge of
		making that service work. Typically, the service will be some sort of
		daemon that offers some functionality across the network after reading
		a configuration file. So your module needs to generate the configuration file and
		start/stop/restart the daemon at the right times.</para>

		<section id='sect-configfiles'>
			<title>Configuration file generation</title>

			<para>The easiest way to generate configuration files is using the
			<application>mason</application> templating engine which is also used
			in the web front-end. Using mason templates is documented in <xref
			linkend='sect-mason'/> so we won't repeat it here.</para>

			<para>Mason templates for configuration files are installed in the
			<filename>stubs</filename> directory under the shared directory
			for eBox. In the module source tree they are usually placed in
			directory of their own called <filename>stubs</filename> too. The
			<filename>Makefile.am</filename> in the <filename>stubs</filename>
			directory for the dns-cache module looks like this:</para>

			<programlisting><![CDATA[Stubdir = @STUBSPATH@/dns-cache

nobase_Stub_DATA = named.conf.mas named.conf.options.mas \
	named.conf.local.mas

EXTRA_DIST = $(nobase_Stub_DATA)

MAINTAINERCLEANFILES = Makefile.in]]></programlisting>

			<para>The <application>autoconf</application> macro included in
			<filename>ebox.m4</filename> automatically exports the stubs
			directory path as <varname>STUBSPATH</varname>, so you just need
			to put create a directory for your module in it and put your mason
			templates there.</para>

			<para>There is a method in <classname>EBox::Module</classname>
			that helps with file permissions and other details. It is called
			<methodname>writeConfFile</methodname> and it takes three
			arguments:</para>

			<itemizedlist>
				<listitem>
					<para>The path of the configuration file that's going to be generated.
					</para>
				</listitem>

				<listitem>
					<para>The path of the mason template relative to the stubs
					directory.</para>
				</listitem>

				<listitem>
					<para>A reference to the arguments that you want to pass to the
					mason template.</para>
				</listitem>
			</itemizedlist>

			<para><methodname>writeConfFile</methodname> will generate the configuration
			file in a temporary location and then copy it on top of the desired
			destination, keeping its original permissions and ownership.</para>

			<example>
				<title>Generating a configuration file</title>

				<para>This is the code that generates the configuration file in the
				ntp module:</para>

				<programlisting>
<![CDATA[
my $self = shift;
my @array = ();
my @servers = $self->servers;
my $synch = 'no';
my $active = 'no';

($self->synchronized) and $synch = 'yes';
($self->service) and $active = 'yes';

push(@array, 'active'   => $active);
push(@array, 'synchronized'  => $synch);
push(@array, 'servers'  => \@servers);

$self->writeConfFile(NTPCONFFILE, "ntp/ntp.conf.mas", \@array);
]]>
				</programlisting>

				<para>And this is the template the generates the
				<filename>ntp.conf</filename> file:</para>

				<programlisting>
<![CDATA[
<%args>
	$active
	$synchronized
	@servers
</%args>	
# /etc/ntp.conf, configuration for ntpd
# Generated by EBox

driftfile /var/lib/ntp/ntp.drift
statsdir /var/log/ntpstats/

% if ($synchronized eq 'yes') {
%	if ($servers[0]) {
server <% $servers[0] %>
%	}
%	if ($servers[1]) {
server <% $servers[1] %>
%	}
%	if ($servers[2]) {
server <% $servers[2] %>
%	}
% }
% if ($active eq 'yes') {
server 127.127.1.0
% }
fudge 127.127.1.0 stratum 13

restrict default kod notrap nomodify nopeer noquery

restrict 127.0.0.1 nomodify
]]>
				</programlisting>
			</example>
	
		</section>

		<section>
			<title>Controlling execution</title>

			<para>The first thing you need to know is when to start and
			stop the daemon you are controlling. Services are started
			by calling the <methodname>restartService</methodname> or
			<methodname>save</methodname> methods on a module instance, however
			those methods are implemented by <classname>EBox::Module</classname>
			and should normally not be overridden, since they takes
			care of logging and/or saving the configuration changes.
			Both of these methods call an abstract method when they
			need to actually start/restart the service. This method is
			<methodname>_regenConfig</methodname>, and it's the one that you need
			to implement.</para>

			<para><methodname>_regenConfig</methodname> should generate
			the configuration files for the daemon and start or restart
			it. A sample implementation of this method can be found in
			<xref linkend='ex-regencfg'/>. If you need to know whether the
			call is caused by a service start/restart or by saving the
			configuration changes, you can check the parameters passed to
			<methodname>_regenConfig</methodname>. When it's called because
			the configuration was saved (<methodname>save()</methodname>)
			the named argument <parameter>save</parameter> will be set
			to <literal>1</literal>, if it is just a regular service
			restart (<methodname>restartService()</methodname>), the
			<parameter>restart</parameter> argument will be set to
			<literal>1</literal>. In most situations you won't need this, since
			you can easily know whether the daemon is running, this is only
			useful for special cases like the network module.</para>

			<para>When <methodname>_regenConfig</methodname> gets called,
			you'll probably need to know whether to start or restart the
			daemon, because choosing the wrong operation may produce an
			error. To make that decision you need to know if the daemon is
			currently running. <classname>EBox::Module</classname> has two
			methods to make this task easier. If you know the process ID of
			the process you can use <methodname>pidRunning</methodname>,
			it receives a process ID as an argument. If you just know the
			name of the file where the daemon stored its process ID, you'll
			want to call <methodname>pidFileRunning</methodname>, which
			takes a file name, checks for a process ID in it and calls
			<methodname>pidRunning</methodname>. Both methods return true if the
			process is running and false if it's not.</para>

			<example id='ex-regencfg'>

				<title>Sample <methodname>_regenConfig</methodname>
				implementation</title>

				<programlisting><![CDATA[sub _regenConfig
{
	my $self = shift;
	$self->_setBindConf;
	$self->_doDaemon();
}

sub _doDaemon
{
	my $self = shift;

	if ($self->service and $self->pidFileRunning(PIDFILE)) {
		$self->_daemon('reload');
	} elsif ($self->service) {
		$self->_daemon('start');
	} elsif ($self->pidFileRunning(PIDFILE)) {
		$self->_daemon('stop');
	}
}

sub _daemon # (action)
{
	my ($self, $action) = @_;
	my $command = BIND9INIT . " " . $action . " 2>&1";

	if ( $action eq 'start') {
		root($command);
	} elsif ( $action eq 'stop') {
		root($command);
	} elsif ( $action eq 'reload') {
		root($command);
	} else {
		throw EBox::Exceptions::Internal(
			"Bad argument: $action");
	}
}]]></programlisting>
				
			</example>

			<para>Stopping the service is similar, you just check if
			it is running and if it is, then run the command that
			stops it. As with <methodname>restartService</methodname>,
			<classname>EBox::Module</classname> has a template implementation
			of the <methodname>stopService</methodname> method, which calls an
			abstract method when it's time to actually stop the service. The
			abstract method, <methodname>_stopService</methodname> is the one you
			need to implement.</para>

			<example>

				<title>Sample <methodname>_stopService</methodname>
				implementation</title>

				<programlisting><![CDATA[sub _stopService
{
	my $self = shift;

	if ($self->pidFileRunning(PIDFILE)) {
		$self->_daemon('stop');
	}
}]]></programlisting>
			</example>

		</section>

	</section>

	<section id='sect-schemas'>
	
		<title>gconf schemas</title>

			<section id='sect-schemas-minimal'> 
			<title>Minimal gconf schema</title>

			<para>A gconf schema is a special gconf key that sets the type and
			default value for some other gconf key. They are stored in the gconf
			database under the <filename>/schemas</filename> directory.</para>

			<para>You will need to create a gconf schema for you module. This is
			needed at least to integrate your module within the framework. By
			means of this schema your module could be instanced. So the first
			thing you should do is to associate the given name for your module
			and its proper perl module. Let's look at an example to clarify this
			idea a little further.</para>

			<para>Say we have a module called <emphasis>foobar</emphasis>,
			and the implementation for this module lies in
			<classname>EBox::Foobar</classname>. Your gconf schema would look
			something like this:</para>

			<example>
			<title>Minimal gconf schema</title>
				<programlisting><![CDATA[<gconfschemafile>
<schemalist>
	<schema>
		<key>/schemas/ebox/modules/global/modules/foobar/class</key>
		<applyto>/ebox/modules/global/modules/foobar/class</applyto>
		<owner>ebox</owner>
		<type>string</type>
		<default>EBox::Foobar</default>
		<locale name="C"/>
	</schema>
</schemalist>
</gconfschemafile>]]></programlisting>
			</example>

			<para>Once you have done this, anytime you instance
			the module <emphasis>foobar</emphasis> using the
			method <methodname>modInstance</methodname> from
			<classname>EBox::Global</classname>, it will know that it has to load
			and instance the class <classname>EBox::Foobar</classname>.</para>
	
			<example>
			<title>Creating a module instance</title>
			<programlisting><![CDATA[my $foobar = EBox::Global->modInstance('foobar');
$foobar->some_method();]]></programlisting>
			</example>
			
		</section>

		<section id='sect-schemas-default'> 
			<title>Default values</title>

			<para>Gconf schemas become useful to establish default values. These
			values will be used by the system when the user has not set a value
			for the corresponding key.</para>

			<para>There is an obvious scenario in which you might be interested
			in using this feature. This is when your module is installed for the
			first time, it could come in handy to set default values for your
			initial configuration.</para>

			<para>Let's illustrate this with a simple example. Imagine you are
			providing a module to manage a HTTP proxy. One of the configurable
			parameters is the listening port. You want the user to have the
			capability to change it, but also you wish to provide 3128 as an
			initial value. Gconf schema is the right place to do it. For 
			this example we would use the key 
			<filename>/schemas/ebox/modules/proxy/port</filename>.</para>

			<example>
				<title>Setting a default value in gconf schemas</title>
				 <programlisting><![CDATA[<schema>
	<key>/schemas/ebox/modules/proxy/port</key>
	<applyto>/ebox/modules/proxy/port</applyto>
	<owner>ebox</owner>
	<type>int</type>
	<default>3128</default>
	<locale name="C"/>
</schema>]]></programlisting>
			</example>
		</section>
			
		<section id='sect-schemas-dependence'> 
		<title>Module dependencies</title>

			<para>It is likely your module configuration depends on some other
			modules. If this occurs to your module, you will be interested in
			being notified anytime that there is a change in any of the modules
			you depend on.</para>

			<para>Continuing with the example used earlier, consider you
			want to configure the proxy for listening solely on the internal
			interfaces. The network module is the one which deals with the
			network interfaces. So at the time of generating the configuration
			for the proxy we will ask the network module for the network
			interfaces configured as internal. This raises an obvious issue, your
			module should regenerate its configuration whenever the internal
			interfaces change, that is, when the network module's configuration
			is changed.</para>

			<para>In order to express this relationship of dependence we will
			use your module's gconf schema as follows:</para>

			<example>
				<title>Setting module dependencies</title>
				 <programlisting><![CDATA[<schema>
	<key>/schemas/ebox/modules/global/modules/proxy/depends</key>
	<applyto>/ebox/modules/global/modules/proxy/depends</applyto>
	<owner>ebox</owner>
	<type>list</type>
	<list_type>string</list_type>
	<default>[network]</default>
	<locale name="C"/>
</schema>]]></programlisting>
			</example>

			<para>The above snippet tells the module global that
			proxy depends on network. This way, global will run
			the method <methodname>_regenConfig</methodname> from
			<classname>EBox::Proxy</classname> when the network module's
			configuration changes.</para>

			<!-- FIXME - sintax for multiple dependencies-->

		</section>
	</section>

	<section id="sect-cfgback">
		<title>Backups</title>

		<para>As we pointed out earlier, all changes made on the keys stored
		in gconf are automatically backed up the first time a write or delete
		operation is carried on. Consequently, all these changes could be
		restored automatically if the user wishes to dismiss or restore them
		from a file.This is actually true as long as you use the methods
		provided by <classname>EBox::GConfModule</classname> to do so.</para>

		<para>If your module has at least some part
		independent from GConf, it must override methods
		<methodname>dumpConfig</methodname> and
		<methodname>restoreConfig</methodname>.</para>
		
		<para>Additionally, apart from module configuration if
		you want to add some other data concerned to the module
		which comprise user files, log content and so on; it
		must implement the methods
		<methodname>extendedBackup</methodname> and
		<methodname>extendedRestore</methodname>. Remember all
		these information will just save and restore whether
		user requests it explicitly. Let's show how with an
		example:</para>

		<example>
		  <title>Overriding backup functions</title>
		  <programlisting><![CDATA[
sub dumpConfig
{
  my ($self, $dir) = @_;
 
  $self->{ldap}->dumpLdapData($dir);
}


sub restoreConfig
{
  my ($self, $dir) = @_;

  $self->{ldap}->loadLdapData($dir);
}
]]></programlisting>
		</example>

		<para><emphasis>ebox-logs</emphasis> module is
		intended to administer eBox logs. We wish to have the
		chance to back up its contents. As module
		configuration does not include these data, we are
		going to use <methodname>extendedBackup</methodname>
		and <methodname>extendedRestore</methodname>. Remember
		that this kind of data is only stored if user chooses
		it.</para>

		explicitly.

		The next example shows how
		<emphasis>ebox-logs</emphasis> implement these
		features:

		<example>
		  <title>Overriding functions for extended
		  backups</title>
		  <programlisting>
<![CDATA[
sub extendedBackup
{
  my ($self, %params) = @_;
  my $dir    = $params{dir};
  
  my $dbengine = EBox::DBEngineFactory::DBEngine();
  my $dumpFile = "$dir/eboxlogs.dump";

  $dbengine->dumpDB($dumpFile);
}


sub extendedRestore
{
  my ($self, %params) = @_;
  my $dir    = $params{dir};

  my $dbengine = EBox::DBEngineFactory::DBEngine();
  my $dumpFile = "$dir/eboxlogs.dump";

  $dbengine->restoreDB($dumpFile);
}
]]>
		  </programlisting>
		</example>
	</section>		

</chapter>

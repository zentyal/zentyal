<!-- vim: ts=2 sw=2
-->
<chapter id="ch-backend">

	<title>Backend del módulo</title>

	<simplesect>

		<para>La plataforma eBox ofrece unos módulos con ciertas
		funcionalidades que están disponibles a través de una API orientada a
		objetos en su mayor parte. No todo está orientado a objetos,
		interfaces procedurales se han usado cuando tenía sentido hacerlo.</para> 

		<para>Algunas de las características de la API funcionan a través de
		herencia, éstas normalmente ofrecen un medio para que el módulo
		implemente las funcionalidades estándar como los menús, la página de
		estado, el guardado de la configuración o su revocación, etc. Algunas
		de estas características necesitan ser implementadas por el módulo
		mientras que otras son completas en la plataforma, y el módulo puede
		extenderlas o sobreescribirlas.</para>

	</simplesect>

	<section id="sect-basemod">
		<title>El módulo base</title>

		<para>Todos los módulos de eBox heredan de la clase
		<classname>EBox::Module</classname>. Esta clase define funciones
		abstractas que los módulos sobreescribirán para implementar una cierta
		funcionalidad. Estas funciones son llamados por la plataforma cuando son
		necesarios.</para>

		<para>Además de estas funciones abstractas, la clase implementa unos
		pocas funciones con algunas funcionalidades básicas. Estas últimas,
		siguen normalmente el método que define una plantilla de un
		patrón de diseño, es decir, realizan algunas operaciones pero delegan
		parte de ellas en alguna función abstracta que deberá ser implementada
		por la clase hija.</para>

		<!-- FIXME - class diagram -->

		<para>Finalmente, hay unas pocas funciones que implementan algunas
		operaciones comunes que son utilizadas por la mayoría de los módulos,
		están escritas para que sean llamadas por las clases hijas cuando se
		les necesita. Están situadas en la clase
		<classname>EBox::Module</classname> únicamente por conveniencia.</para>

		<section id="sect-modconstructor">
			<title>Constructor del módulo</title>

			<para>Todas las instancias del módulo son creadas y cacheadas
			por la clase <classname>Ebox::Global</classname>. Los
			constructores de un módulo no deben ser llamados directamente
			excepto por la clase <classname>EBox::Global</classname>. Por
			esta razón, se llaman <methodname>_create</methodname> en vez
			de <methodname>new</methodname>.</para>

			<para>El primer guión bajo en el nombre de la función es una
			convención de nombres. Las funciones con un nombre así están
			pensadas para ser usados de forma privada por su propia clase
			y por sus clases ascendentes. No deberían ser llamadas
			directamente por cualquier otra clase que no tenga una
			relación de este tipo. En el caso del constructor del módulo,
			la única clase que debería llamarlo es
			<classname>Ebox::Global</classname>.</para>

			<para>La función <methodname>_create</methodname> en
			<classname>EBox::Module</classname> recibe dos argumentos
			desde sus clases hijas. <parameter>name</parameter> es el
			nombre del módulo y es obligatorio;
			<parameter>domain</parameter>es el dominio
			<application>gettext</application> para el módulo, es
			opcional, y <quote>ebox</quote> es su valor por defecto.</para>

			<example>
				<title>Sencillo constructor de un módulo</title>
				<programlisting><![CDATA[sub _create
{
	my $class = shift;
	my $self = $class->SUPER::_create(name => 'dhcp',
					domain => 'ebox-dhcp',
					@_);
	bless ($self, $class);
	return $self;
}]]></programlisting>
			</example>

		</section>

	</section>

	<section id="sect-rootcmds">
		<title>Comandos de root</title>

		<para>El servidor apache bajo el que funciona eBox y cualquier otro
		script de perl que utilice el API de eBox, utilizan un id de usuario
		dedicado. El usuario es normalmente llamado <quote>ebox</quote>. Los
		módulos de eBox necesitan ejecutar ciertos comandos y escribir ciertos
		ficheros con privilegios de root, esto se hace usando
		<application>sudo</application>. 
                 </para>


		<para>Se puede llamar a cualquier comando utilizando la función <methodname>root()</methodname> en el paquete
		perl <classname>EBox::Sudo</classname>. Si el comando falla,
		<methodname>root()</methodname> lanza una excepción de tipo <classname>EBox::Exceptions::Sudo::Command</classname>, asegúrese de que sea capturada si es correcto que el comando falle o
		si desea informar al usuario de una forma distinta. En cualquier caso se pueden usar los métodos <methodname>output</methodname>,
                <methodname>error</methodname> y   <methodname>exitValue</methodname> para obtener más información sobre el fallo de comando. En los raros casos en lo que el propio programa sudo falla la excepción levantada es del tipo <classname>EBox::Exceptions::Sudo::Wrapper</classname> y los últimos métodos no estarán disponibles.
                </para>

			<example>
				<title>Using EBox::Sudo::root()</title>
				<programlisting><![CDATA[try {
  EBox::Sudo::root("/usr/bin/eject -t");
}
catch EBox::Exceptions::Sudo::Wrapper with {
  throw EBox::Exceptions::Internal("sudo program failed");
}
catch EBox::Exceptions::Sudo::Command with {
  my ($ex) = @_;
  EBox::debug("/usr/bin/eject failed. Stderr was " . (join "\n", @{ $ex->error() })) ;
  throw EBox::Exceptions::External("Cannot close CD-ROM tray. Please close it manually" );
}
]]></programlisting>
			</example>

                <para> 
                 <classname>EBox::Sudo</classname> provee funciones de interfaz con comandos
                  frecuentemente ejecutados con privilegios de superusuario.
                 <methodname>stat</methodname> propociona interfaz con el programa stat, resulta 
                 util para obtener informacion sobre cualquier archivo. Si necesitas una infromacion mas concisa sobre el archivo puedes usar <methodname>fileTest</methodname> para
                 realizar comprobaciones simples sobre archivos, como hace el programa <application>/usr/bin/test</application>.

                </para>


	</section>

	<section id="sect-gconf">
		<title><classname>EBox::GConfModule</classname></title>

		<para>eBox utiliza GConf para almacenar su configuración. La
		plataforma de desarrollo ofrece un recubrimiento sobre los <ulink
		url='http://gtk2-perl.sourceforge.net/doc/pod/Gnome2/GConf.html'>
		bindings originales de perl</ulink>. GConf ofrece una sencilla API
		para almacenar y consultar configuración con valores clasificados por
		tipos y organizada jerárquicamente. También nos permite definir
		esquemas limitados para algunas claves de configuración, configurando
		sus tipos y valores por defecto.</para>

		<!-- FIXME - example -->

		<para>La plataforma de desarrollo define un recubrimiento sobre el API
		de GConf más algunas funcionalidades añadidas. El recubrimiento es
		implementado como una clase hija de
		<classname>Ebox::Module</classname>, así que todos los módulos que
		quieren usar GConf heredan de
		<classname>EBox::GConfModule</classname>. Sus hijos automáticamente
		adquieren estas características:</para>

		<itemizedlist>

			<listitem>

				<para>Copias de seguridad automáticos: La primera vez
				que la clave de un valor es modificada, se hace una
				copia de seguridad del árbol completo de configuración
				para ese módulo. Cuando la configuración se guarda, la
				copia de seguridad es automáticamente
				eliminada. Cuando los cambios en la configuración son
				descartados, la copia de seguridad es automáticamente
				recuperada. <classname>EBox::GConfModule</classname>
				implementa las funciones
				<methodname>makeBackup</methodname>,
				<methodname>restoreBackup</methodname> y
				<methodname>revokeConfig</methodname> definidas en la
				clase <classname>EBox::Module</classname>, por lo que
				las clases hijas de
				<classname>EBox::GConfModule</classname> no necesitan
				implementar estas funciones a no ser que se necesite
				algún requisito en especial o almacenar parte de su
				configuración fuera de GConf.</para>


			</listitem>
			<listitem>

				<para>Manejo de errores: Los errores de GConf son
				manejados por la clase recubridora. Ella los traduce
				a excepciones internas.</para>

			</listitem>
			<listitem>

				<para>Instancias de sólo-lectura y sólo-escritura:
				Cuando el módulo es instanciado en modo sólo-lectura,
				la clase recubridora utiliza una copia de la
				configuración para evitar ver que hay cambios sin
				guardar. También previene de llamadas a métodos que
				escriban en GConf.</para>

			</listitem>
			<listitem>

				<para>Comprobación de los límites del espacio de
				nombre: El recubrimiento comprueba todas las claves de
				GConf utilizadas por el módulo, para ver si están en
				su espacio de nombres. Esto asegura que las claves
				para un módulo sólo son leídas o escritas directamente
				por el propio módulo (siempre que todos los módulos
				utilicen esta clase recubridora).</para>

			</listitem>
			<listitem>

				<para>Rutas relativas: las funciones en la clase
				recubridora pueden recibir para las claves de gconf
				tanto rutas absolutas como relativas. La raíz del
				espacio de nombres de un módulo cambia dependiendo del
				tipo de instancia (sólo-lectura o lectura-escritura) y
				el tipo de clave (normal o de estado) a la cual se
				acceda. Por esta razón lo mejor es utilizar rutas
				relativas cuando se llamen a las funciones de la clase
				recubridora, ya que ellas traducen la ruta relativa en
				una ruta absoluta automáticamente.</para>

			</listitem>
			<listitem>

				<para>Estado del espacio de nombres: hay cierta
				información que no es suministrada por el usuario y
				que necesita ser escrita en cualquier momento, incluso
				en las instancias de sólo-lectura. Este tipo de
				información no está sujeta a guardar o cancelar la
				configuración. Es la información de estado, como los
				nombres de los servidores o la dirección IP dada por
				el sistema por un servidor DHCP externo. Un espacio de
				nombres aparte está disponible para este tipo de
				información, y de nuevo es automáticamente apartado de
				las operaciones de copia de seguridad, guardado y
				cancelación mencionadas anteriormente. Las funciones
				que suelen acceder a este espacio de nombres son
				idénticas a las normales, sólo que tienen el prefijo
				<literal>st_</literal> en sus nombres.</para>

			</listitem>

			<listitem>

				<para>Recuperación recursiva de directorios: hay dos
				funciones en <classname>EBox::GConfModule</classname>
				que permiten fácilmente recuperar la estructura
				completa de
				directorios. <methodname>hash_from_dir</methodname>
				toma un directorio como argumento y devuelve un hash
				con todas las claves que están por debajo
				suyo. <methodname>array_from_dir</methodname> toma un
				directorio como argumento y devuelve un array de
				hashes tal y como devuelve
				<methodname>hash_from_dir</methodname> para cada uno
				de sus subdirectorios.</para>

			</listitem>

		</itemizedlist>

		<para>Esta es la lista de las funciones más importantes en
		<classname>EBox::GConfModule</classname>:</para>

		<variablelist>
			<varlistentry>
				<term><methodname>all_dirs</methodname></term>
				<listitem>

					<para>Dada una clave, devuelve todos los
					directorios de su interior.</para>
				
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>all_dirs_base</methodname></term>
				<listitem>

					<para>Dada una clave, devuelve todos los
					directorios de su interior, eliminando
					cualquier directorio que aparezca por delante.</para>
				
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>all_entries</methodname></term>
				<listitem>

					<para>Dada una clave, devuelve todas las
					entradas de su interior. Estas entradas son
					todas aquellas claves que no son directorios,
					por lo que contendrán un valor.</para>
					
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><methodname>all_entries_base</methodname></term>
					<listitem>

					<para>Dada una clave, devuelve todas las
					de su interior, eliminando cualquier
					directorio que aparezca por delante. Las
					entradas son todas aquellas claves que no son
					directorios, por lo que contendrán un valor.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>array_from_dir</methodname></term>
				<listitem>

					<para>Dada una clave, devuelve un array
					utilizando una referencia a un hash para
					contener en cada elemento los directorios bajo
					su clave. También, el hash contiene la clave
					<structfield>_dir</structfield> que dice cual
					es el nombre del directorio.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>dir_exists</methodname></term>
				<listitem>

					<para>Dada una clave que referencia un
					directorio, devuelve <literal>true</literal>
					si existe.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_bool</methodname></term>
				<listitem>

					<para>Devuelve el valor de una clave de tipo booleano.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_int</methodname></term>
				<listitem>

					<para>Devuelve el valor de una clave de tipo entero.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_list</methodname></term>
				<listitem>

					<para>Devuelve un array conteniendo la lista
					referenciada por la clave.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_string</methodname></term>
				<listitem>

					<para>Devuelve el valor de una clave de tipo cadena.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_unique_id</methodname></term>
				<listitem>
					
					<para>General un identificado único aleatorio
					con un <parameter>prefix</parameter> delante
					en la raíz del nombre del espacio del
					módulo. Si <parameter>directory</parameter> es
					pasado, será añadido a la ruta. Notar que esto
					no crea la entrada, únicamente devuelve un
					identificador único, así que es tarea del
					programador crear la entrada correctamente.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>hash_from_dir</methodname></term>
				<listitem>
					
					<para>Devuelve un hash conteniendo todas las
					entradas del directorio referenciado por la clave.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>isReadOnly</methodname></term>
				<listitem>

					<para>Devuelve <literal>true</literal> si la
					instancia actual de
					<classname>EBox::GConfModule</classname> a la
					que se está accediendo es de sólo-lectura.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>makeBackup</methodname></term>
				<listitem>

					<para>Vuelca el contenido actual de la
					configuración a un fichero.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>restoreBackup</methodname></term>
				<listitem>

					<para>Recupera el último backup.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>revokeConfig</methodname></term>
				<listitem>

					<para>Todos los cambios hechos desde que se
					escribió o eliminó algo serán descartados.</para>
					
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>set_bool</methodname></term>
				<listitem>

					<para>Asigna un <parameter>valor</parameter>
					booleano a una <parameter>clave</parameter>.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>set_int</methodname></term>
				<listitem>

					<para>Asigna un <parameter>valor</parameter>
					entero a una
					<parameter>clave</parameter>.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>set_list</methodname></term>
				<listitem>

					<para>Asigna una lista de
					<parameter>valores</parameter> de un
					<parameter>tipo</parameter> en un
					<parameter>valor</parameter>.</para>
				
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>set_string</methodname></term>
				<listitem>

					<para>Asigna un <parameter>valor</parameter>
					de tipo cadena en la <parameter>clave</parameter>.</para>

				</listitem>
			</varlistentry>
		</variablelist>

		<para>Veamos algunos ejemplos de las funciones anteriormente descritas.</para>
		
		<example>
			<title>Asignando un valor de tipo cadena</title>
			<programlisting> <![CDATA[$self->set_string("printers/x4235/name", "fooprinter"); ]]></programlisting>
		</example>

		<example>
			<title>Asignando una lista de cadenas</title>
			<programlisting><![CDATA[$self->set_list('foo/foolist', 'string', ['foo', 'bar']);]]></programlisting>
		</example>

		<example>
			<title>Recogiendo y usando un identificador único</title>
			<programlisting><![CDATA[my $id = $self->get_unique_id('p', 'printers');
$self->set_string("printers/$id/name", $name);
$self->set_bool("printers/$id/configured", undef);
		]]></programlisting>
		</example>
	</section>

	<section id="sect-ordering">
		<title>Ordenando cosas</title>

		<para>La necesidad de mantener cierta información ordenada es muy
		normal en los módulos eBox. También es común ofrecer funciones de
		reordenación. Un ejemplo claro son las reglas del firewall, las cuales
		necesitan ser aplicadas en un cierto orden, y el usuario ha de
		poderles cambiar su orden. La clase <classname>EBox::Order</classname>
		resuelve justamente este problema.</para>
		
		<para>La idea es dar un directorio a cada objeto que se quiere
		mantener ordenado. Siguiendo con el ejemplo del firewall, podríamos
		tener el directorio <filename>rules/</filename> y, por debajo, un
		directorio por regla. Cada regla tendría un identificador único, y eso
		sería el nombre de su directorio bajo <filename>rules/</filename>. Una
		regla con el id <literal>r3561</literal> se almacenaría en
		<filename>rules/r3561</filename>, y debajo de ese directorio se
		almacenarían las claves con cada uno de los parámetros de la
		regla. Ésta es la forma más natural de organizar elementos como reglas
		de firewall, y es con una organización de este tipo para lo que está
		diseñado <classname>EBox::Order</classname> para trabajar.</para>

		<!-- FIXME example -->

		<para>El mecanismo de ordenación añade un campo a los objetos para ser
		ordenados. Lógicamente, se le ha denominado
		<structfield>order</structfield>. Para usar el API de ordenación ha de
		crear una instancia de <classname>EBox::Order</classname>. Su
		constructor toma como argumentos: la instancia del módulo al que
		pertenecen los objetos que van a ser ordenados y el directorio base
		donde los objetos serán almacenados.</para>

		<para><classname>EBox::Order</classname> implementa estas
		operaciones:</para>

		<variablelist>

			<varlistentry>
				<term><methodname>highest</methodname></term>
				<listitem>

					<para>Devuelve la clave
					<structfield>order</structfield> más alta de
					todos los objetos.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>lowest</methodname></term>
				<listitem>

					<para>Devuelve la clave
					<structfield>order</structfield> más baja de
					todos los elementos.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>nextn</methodname></term>
				<listitem>

					<para>Dado un número, devuelve la clave
					<structfield>order</structfield> del siguiente
					objeto.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>prevn</methodname></term>
				<listitem>

					<para>Dado un número, devuelve la clave 
					<structfield>order</structfield> del objeto
					anterior.</para> 

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>get</methodname></term>
				<listitem>

					<para>Devuelve el identificador del objeto
					cuya clave <structfield>order</structfield> es
					igual a un número dado.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>swap</methodname></term>
				<listitem>

					<para>Encuentra los objetos cuyas claves
					<structfield>order</structfield> coinciden con
					los dos números dados e intercambia sus valores.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>list</methodname></term>
				<listitem>

					<para>Devuelve una referencia a un array que
					contenga los identificadores de todos los
					objetos, ordenados del más bajo al más alto.</para>

				</listitem>
			</varlistentry>

		</variablelist>

		<example>
			<title>Ordenando las reglas del firewall</title>

			<para>Vamos a ver como utiliza
			<classname>EBox::Order</classname> el módulo firewall para
			mantener sus reglas de forwarding ordenadas. La función
			<methodname>_fwdRulesOrder</methodname> devuelve la instancia
			de <classname>EBox::Order</classname> de las reglas del firewall:</para>
			
			<programlisting><![CDATA[sub _fwdRulesOrder
{
	my $self = shift;
	return new EBox::Order($self, "fwdrules");
}]]></programlisting>

			<para><filename>fwdrules</filename> es el directorio que
			contiene todas las reglas. Otra función auxiliar privada es
			<methodname>_fwdRuleNumber</methodname>, la cual devuelve el
			número de orden para el identificador de una regla dada:</para>

			<programlisting><![CDATA[sub _fwdRuleNumber # (rule)
{
	my ($self, $rule) = @_;
	return $self->get_int("fwdrules/$rule/order");
}]]></programlisting>

			<para>Las nuevas reglas son añadidas al final de la lista, por
			lo que vamos a buscar el número de orden más alto y le
			añadiremos una nueva. Este código es parte de la función
			<methodname>addFwdRule</methodname>:</para>

			<programlisting><![CDATA[my $order = $self->_lastFwdRule() + 1;

$self->set_string("fwdrules/$id/name", $id);
$self->set_string("fwdrules/$id/action", $action);
$self->set_bool("fwdrules/$id/active", 1);
$self->set_int("fwdrules/$id/order", $order);]]></programlisting>

			<para><methodname>_lastFwdRule</methodname> es una función
			recubridora trivial que devuelve el número de orden más alto:</para>

			<programlisting><![CDATA[sub _lastFwdRule
{
	my $self = shift;
	my $order = $self->_fwdRulesOrder();
	defined($order) or return 0;
	return $order->highest;
}]]></programlisting>

			<para>Finalmente hay dos funciones que admiten la reordenación
			de las reglas, éstas son <methodname>FwdRuleUp</methodname> y
			<methodname>FwdRuleDown</methodname> (mostramos sólo la
			primera dado que son prácticamente idénticas):</para>

			<programlisting><![CDATA[sub FwdRuleUp # (rule)
{
	my ($self, $rule) = @_;
	my $order = $self->_fwdRulesOrder();
	defined($order) or return;
	my $num = $self->_fwdRuleNumber($rule);
	if ($num == 0) {
		return;
	}
	my $prev = $order->prevn($num);
	$order->swap($num, $prev);
}]]></programlisting>
		</example>

	</section>

	<section id="sect-config-and-daemons">
		<title>Controlando un demonio</title>

		<para>Además de tener un API que permite leer y cambiar la
		configuración de un servicio dado, el backend de un módulo está a
		cargo de hacer que el servicio funcione. Típicamente, el servicio será
		algún tipo de demonio que ofrezca algunas funcionalidades a través de
		la red después de leer su fichero de configuración. Por tanto, el
		módulo creado necesitará generar el fichero de configuración y
		parar/arrancar/reiniciar el demonio las veces que sea necesario.</para>

		<section id='sect-configfiles'>
			<title>Generación del fichero de configuración</title>

			<para>La forma más sencilla de generar el fichero de
			configuración es usar el sistema de plantillas
			<application>mason</application> el cual es usado también en
			el front-end web. El uso de las plantillas de mason está
			documentado en <xref linkend='sect-mason'/> así que no lo
			repetiremos aquí.</para>

			<para>Las plantillas de mason para los ficheros de
			configuración son instaladas en el directorio
			<filename>stubs</filename> baje el directorio compartido para
			eBox. En el árbol de directorios del código fuente, cada
			módulo también tiene normalmente un directorio llamado
			<filename>stubs</filename>. El fichero
			<filename>Makefile.am</filename> del directorio
			<filename>stubs</filename> para el módulo dnscache tiene esta
			forma:</para>
			
			<programlisting><![CDATA[Stubdir = @STUBSPATH@/dns-cache

nobase_Stub_DATA = named.conf.mas named.conf.options.mas \
	named.conf.local.mas

EXTRA_DIST = $(nobase_Stub_DATA)

MAINTAINERCLEANFILES = Makefile.in]]></programlisting>

			<para>La macro de <application>autoconf</application>, llamada
			<filename>ebox.m4</filename>, incluida automáticamente exporta
			la ruta del directorio stubs como <varname>STUBPATH</varname>,
			por lo que sólo se necesita crear un directorio para el módulo
			en dicha ruta y colocar las plantilla de mason en su
			interior.</para>
			
			<para>Hay un método en <classname>EBox::Module</classname> que
			ofrece ayuda con los permisos de los ficheros y otros
			detalles. Se llama <methodname>writeConfFile</methodname> y
			necesita tres argumentos:</para>
			
			<itemizedlist>
				<listitem>
					<para>La ruta del fichero de configuración que
						va a ser generado.</para>
				</listitem>

				<listitem>
					<para>La ruta de la plantilla de mason
					relativa al directorio stubs.</para>
				</listitem>

				<listitem>
					<para>Una referencia a los argumentos que se
					le quieren pasar a la plantilla de
					mason.</para>
				</listitem>
			</itemizedlist>

			<para><methodname>writeConfFile</methodname>generará el
			fichero de configuración en un directorio temporal y después
			lo copiará encima del fichero que exista en el directorio
			deseado, manteniendo sus propietarios y permisos originales.</para>

			<example>
				<title>Generando un fichero de configuración</title>

				<para>Este es el código que genera el fichero de
				configuración en el módulo NTP:</para>

				<programlisting>
<![CDATA[
my $self = shift;
my @array = ();
my @servers = $self->servers;
my $synch = 'no';
my $active = 'no';

($self->synchronized) and $synch = 'yes';
($self->service) and $active = 'yes';

push(@array, 'active'   => $active);
push(@array, 'synchronized'  => $synch);
push(@array, 'servers'  => \@servers);

$self->writeConfFile(NTPCONFFILE, "ntp/ntp.conf.mas", \@array);
]]>
				</programlisting>

				<para>Y esta es la plantilla que genera el fichero <filename>ntp.conf</filename>:</para>


				<programlisting>
<![CDATA[
<%args>
	$active
	$synchronized
	@servers
</%args>	
# /etc/ntp.conf, configuration for ntpd
# Generated by EBox

driftfile /var/lib/ntp/ntp.drift
statsdir /var/log/ntpstats/

% if ($synchronized eq 'yes') {
%	if ($servers[0]) {
server <% $servers[0] %>
%	}
%	if ($servers[1]) {
server <% $servers[1] %>
%	}
%	if ($servers[2]) {
server <% $servers[2] %>
%	}
% }
% if ($active eq 'yes') {
server 127.127.1.0
% }
fudge 127.127.1.0 stratum 13

restrict default kod notrap nomodify nopeer noquery

restrict 127.0.0.1 nomodify
]]>
				</programlisting>
			</example>
	
		</section>

		<section>
			<title>Controlando la ejecución</title>

			<para>La primera cosa que necesita saber es cuando iniciar y
			para el demonio que se está controlando. Los servicios son
			arrancados llamando a las funciones
			<methodname>restartService</methodname> o
			<methodname>save</methodname> en la instancia de un módulo,
			sin embargo estos métodos son implementados por
			<classname>EBox::Module</classname> y no deberían ser
			reimplementados normalmente, siendo que controlan los
			registros del sistema y/o guardan los cambios de
			configuración. Ambas funciones llaman a una función abstracta
			cuando necesitan iniciar/reiniciar el servicio. Este método es
			<methodname>_regenConfig</methodname>, y es el que necesita implementar.</para>

			<para><methodname>_regenConfig</methodname> debería generar
			los ficheros de configuración para el demonio e iniciarlo o
			reiniciarlo. Un ejemplo de implementación de este módulo se
			encuentra en <xref linkend='ex-regencfg'/>. Si necesita saber
			cuando la llamada es realizada por el inicio/reinicio del
			servicio o por la petición de guardar los cambios en la
			configuración, puede comprobar los parámetros pasados a
			<methodname>_regenConfig</methodname>. Cuando se llama porque
			la configuración fue guardada
			(<methodname>save()</methodname>) el argumento llamado
			<parameter>save</parameter> será puesto a
			<literal>1</literal>. En la mayoría de situaciones no será
			esto necesario, ya que se puede saber fácilmente si el demonio
			está ejecutándose, y sólo es útil para casos especiales como
			el módulo network.</para>

			<para>Cuando se llama a <methodname>_regenConfig</methodname>,
			probablemente necesite saber cuando iniciar o reiniciar el
			demonio, porque elegir la operación incorrecta podría producir
			un error. Para realizar tal decisión necesita saber si el
			demonio se encuentra funcionando en ese
			momento. <classname>EBox::Module</classname> tiene dos
			funciones para hacer esta tarea más sencilla. Si sabe cual es
			el ID del proceso, puede usar
			<methodname>pidRunning</methodname>. Recibe el ID de un
			proceso como argumento. Si sólo sabe el nombre del fichero
			donde el demonio almacenó su ID de proceso, querrá llamar a la
			función <methodname>pidFileRunning</methodname>, el cual toma
			el nombre de un fichero, comprueba el ID del proceso y llama a
			<methodname>pidRunning</methodname>. Ambas funciones devuelven
			true si el proceso está funcionando y false si no lo está.</para>

			<example id='ex-regencfg'>
			        <title>Ejemplo de implementación de <methodname>_regenConfig</methodname></title>

				<programlisting><![CDATA[sub _regenConfig
{
	my $self = shift;
	$self->_setBindConf;
	$self->_doDaemon();
}

sub _doDaemon
{
	my $self = shift;

	if ($self->service and $self->pidFileRunning(PIDFILE)) {
		$self->_daemon('reload');
	} elsif ($self->service) {
		$self->_daemon('start');
	} elsif ($self->pidFileRunning(PIDFILE)) {
		$self->_daemon('stop');
	}
}

sub _daemon # (action)
{
	my ($self, $action) = @_;
	my $command = BIND9INIT . " " . $action . " 2>&1";

	if ( $action eq 'start') {
		root($command);
	} elsif ( $action eq 'stop') {
		root($command);
	} elsif ( $action eq 'reload') {
		root($command);
	} else {
		throw EBox::Exceptions::Internal(
			"Bad argument: $action");
	}
}]]></programlisting>
				
			</example>

			<para>Parar el servicio es similar. Se puede comprobar si está
			ejecutándose, y si es así, entonces lanzar el comando que lo
			pare. Como con <methodname>restartService</methodname>,
			<classname>EBox::Module</classname> tiene una implementación
			básica de la función <methodname>stopService</methodname>, la
			cual llama a una función abstracta cuando es momento de parar
			el servicio. La función abstracta,
			<methodname>_stopService</methodname> es la que se necesita
			implementar.</para>

			<example>

				<title>Implementación de
				<methodname>_stopService</methodname> de ejemplo</title>

				<programlisting><![CDATA[sub _stopService
{
	my $self = shift;

	if ($self->pidFileRunning(PIDFILE)) {
		$self->_daemon('stop');
	}
}]]></programlisting>
			</example>

		</section>

	</section>

	<section id='sect-schemas'>
		<title>Esquemas de GConf</title>

			<section id='sect-schemas-minimal'> 
			<title>Esquema de GConf mínimo</title>

			<para>Un esquema de GConf es una clave especial de GConf que
			configura el tipo y el valor por defecto de alguna clave de
			GConf. Son almacenados en la base de datos de GConf bajo el
			directorio <filename>/schemas</filename>.</para>

			<para>Necesitará crear un esquema de GConf para el
			módulo. Esto es necesario, al menos para integrar el módulo con
			la plataforma. Por medio de este esquema, el módulo podrá ser
			instanciado. Por tanto, la primera cosas que se deberá hacer
			es asociar el nombre dado para el módulo y su módulo de
			perl. Veamos el ejemplo para clarificar un poco más esta idea:</para>
			
			<para>Digamos que tenemos un módulo llamado
			<emphasis>foobar</emphasis> y la implementación para este
			módulo recae en <classname>EBox::Foobar</classname>. El
			esquema de GConf sería algo así:</para>

			<example>
			<title>Esquema de GConf mínimo</title>
				<programlisting><![CDATA[<gconfschemafile>
<schemalist>
	<schema>
		<key>/schemas/ebox/modules/global/modules/foobar/class</key>
		<applyto>/ebox/modules/global/modules/foobar/class</applyto>
		<owner>ebox</owner>
		<type>string</type>
		<default>EBox::Foobar</default>
		<locale name="C"/>
	</schema>
</schemalist>
</gconfschemafile>]]></programlisting>
			</example>

			<para>Una vez que ha hecho esto, cada vez que se instancie el
			módulo <emphasis>foobar</emphasis> utilizando el método
			<methodname>modInstance</methodname> de
			<classname>EBox::Global</classname>, sabrá que tiene que
			cargar e instanciar la clase
			<classname>EBox::Foobar</classname>.</para>

			<example>
			<title>Creando la instancia de un módulo</title>
			<programlisting><![CDATA[my $foobar = EBox::Global->modInstance('foobar');
$foobar->some_method();]]></programlisting>
			</example>
			
		</section>

		<section id='sect-schemas-default'>
			<title>Valores por defecto</title>

			<para>Los esquemas de GConf son útiles para estableces valores
			por defecto. Estos valores se usarán por el sistema cuando el
			usuario no ha dado un valor a la clave correspondiente.</para>

			<para>Hay un escenario obvio en el cual puede estar interesado
			en utilizar estas características. Este es cuando su módulo es
			instalado por primera vez. Podría ser útil configurar unos
			valores por defecto en la configuración inicial.</para>

			<para>Vamos a ilustrar esto con un pequeño ejemplo. Imagine
			que está desarrollando un módulo para manejar un proxy
			HTTP. Uno de los parámetros configurables es el puerto por
			donde escucha. Desea que el usuario tenga la capacidad de
			cambiarlo, pero también desea que tenga como valor inicial
			configurado, el puerto 3128. El esquema de GConf es el sitio
			ideal para hacerlo. Para este ejemplo, usaremos la clave
			<filename>/schemas/ebox/modules/proxy/port</filename>.</para>

			<example>
				<title>Configurando un valor por defecto en los
				esquemas de GConf</title>
				 <programlisting><![CDATA[<schema>
	<key>/schemas/ebox/modules/proxy/port</key>
	<applyto>/ebox/modules/proxy/port</applyto>
	<owner>ebox</owner>
	<type>int</type>
	<default>3128</default>
	<locale name="C"/>
</schema>]]></programlisting>
			</example>
		</section>
			
		<section id='sect-schemas-dependence'> 
		<title>Dependencias de módulos</title>

			<para>Es cuestión de la configuración de su módulo que pueda
			depender de otros. Si esto ocurre, estará interesado en que le
			sea notificado cada vez que hay un cambio en cualquiera de los
			módulos de los que depende.</para>

			<para>Continuando con el ejemplo utilizado anteriormente,
			considere que desea configurar el proxy para que escuche
			únicamente en los interfaces internos. El módulo
			<emphasis>network</emphasis> se el único que maneja los
			interfaces de red. Así que en el momento de generar la
			configuración del proxy, se le pedirá al módulo
			<emphasis>network</emphasis> los interfaces de red
			configurados como internos. Esto levanta una duda obvia, el
			módulo debería regenerar su configuración cuando el interfaz
			interno cambia, esto es, cuando la configuración del módulo
			<emphasis>network</emphasis> cambie.</para>

			<para>Para expresar esta relación de dependencia haremos uso
			del esquema de gconf del módulo de esta forma:</para>

			<example>
				<title>Configurando dependencias entre módulos</title>
				 <programlisting><![CDATA[<schema>
	<key>/schemas/ebox/modules/global/modules/proxy/depends</key>
	<applyto>/ebox/modules/global/modules/proxy/depends</applyto>
	<owner>ebox</owner>
	<type>list</type>
	<list_type>string</list_type>
	<default>[network]</default>
	<locale name="C"/>
</schema>]]></programlisting>
			</example>

			<para>El trozo de código le dice al módulo global que proxy
			depende de network. De esta forma, el módulo global lanzará la
			función <methodname>_regenConfig</methodname> de
			<classname>EBox::Proxy</classname> cuando la configuración del
			módulo de red cambie.</para>

			<!-- FIXME - sintax for multiple dependencies-->

		</section>
	</section>

	<section id="sect-cfgback">
        <title>Copias de seguridad</title>

		<para>Como señalábamos con anterioridad, todos los cambios hechos en
		las claves almacenadas en gconf son automáticamente guardados la
		primera vez que se efectúa una operación de escritura o borrado. En
		consecuencia, todos esos cambios pueden ser recuperados
		automáticamente si el usuario desea descartar o recuperarlos de un
		fichero. Por supuesto esto ocurre siempre que se usen las funciones
		provistas a tal efecto por <classname>EBox::GConfModule</classname>.</para>

		<para>Si su módulo tiene parte o la totalidad de su configuración independiente
                 de GConf, deberá implementar los métodos <methodname>dumpConfig</methodname> y
		<methodname>restoreConfig</methodname>.</para>

                <para>Adicionalmente, si aparte de la configuración
		desea copiar otros tipo de datos asociados al módulo
		que no forman parte de su configuración, como por
		ejemplo ficheros de usuarios, deberá también implementar los
		métodos <methodname>extendedBackup</methodname> y
		<methodname>extendedRestore</methodname>. Recuerde que
		este tipo de información sólo será guardada y
		restaurada si el usuario lo solicita
		explícitamente. </para> 

		<para>El módulo <emphasis>usersandgroups</emphasis>
		almacena su configuración (usuarios, grupos,
		contraseñas, ..) en el servidor de LDAP. Por este
		motivo deberemos guardar y recuperar posteriormente la
		información guardada en <emphasis>openldap</emphasis>
		para poder realizar copias de seguridad de este módulo
		correctamente. Veamos como podemos hacerlo:</para>
		
		<example>
			<title>Sobreescribiendo funciones para las copias de seguridad</title>
				<programlisting><![CDATA[
sub dumpConfig
{
  my ($self, $dir) = @_;
 
  $self->{ldap}->dumpLdapData($dir);
}


sub restoreConfig
{
  my ($self, $dir) = @_;

  $self->{ldap}->loadLdapData($dir);
}
]]></programlisting>
		</example>

		<para>El módulo <emphasis>ebox-logs</emphasis> es el
		encargado de la administración de los registros de
		eBox. Deseamos tener la posibilidad de hacer copia de
		seguridad de sus contenidos. Como dichos contenidos no
		forman parte de la configuración del módulo usaremos
		<methodname>extendedBackup</methodname> y
		<methodname>extendedRestore</methodname>. Los datos no
		pertenecientes a la configuración sólo se almacenarán
		en la copia de seguridad si el usuario así lo elige.
		</para>

		A continuación, mostramos como
		<emphasis>ebox-logs</emphasis> implementa estas	características:

		<example>
			<title>Sobreescribiendo funciones para las copias de seguridad extendidas</title>
				<programlisting><![CDATA[
sub extendedBackup
{
  my ($self, %params) = @_;
  my $dir    = $params{dir};
  
  my $dbengine = EBox::DBEngineFactory::DBEngine();
  my $dumpFile = "$dir/eboxlogs.dump";

  $dbengine->dumpDB($dumpFile);
}


sub extendedRestore
{
  my ($self, %params) = @_;
  my $dir    = $params{dir};

  my $dbengine = EBox::DBEngineFactory::DBEngine();
  my $dumpFile = "$dir/eboxlogs.dump";

  $dbengine->restoreDB($dumpFile);
}
         	]]></programlisting>
	</example>
	</section>	
	<section id="sect-logAdmin">
	  <title>Registro administrativo</title>
	  
	  <para>
	    eBox puede registrar cada cambio realizado a través de interfaz
	    administrativo, lo que es útil para saber cuando se ha cambiado o 
	    quién lo ha hecho. Cada módulo eBox debería dar parte de cada mensaje
	    de registro para dar un soporte completo al registro administrativo.
	  </para>

	  <para>
	    Para conseguirlo, debes incluir un nuevo paquete del núcleo eBox
	    <classname>EBox::LogAdmin</classname> en tu módulo.
	  </para>
	  
	  <example>
	    <title>Incluyendo el paquete LogAdmin</title>
	    <programlisting><![CDATA[
use EBox::LogAdmin qw ( :all );
]]></programlisting>
	  </example>

	  <para>
	    Se usa un nuevo atributo del módulo, <emphasis>title</emphasis>,
	    debes añadirlo a la llamada de creación del módulo. Por ejemplo:
	  </para>
	  
	  <example>
	    <title>Creando un objeto con soporte a registro administrativo</title>
	    <programlisting><![CDATA[
my $self = $class->SUPER::_create(name => 'objects',
                    title => __n('Objects'),
                    domain => 'ebox-objects',
                    @_);
]]></programlisting>
	  </example>

	  <para>
	    Además, se necesita una tabla hash en el constructor con las actiones que 
	    tu módulo reportará con una formato de mensaje bonito.
	    Siguiendo el mismo ejemplo en el módulo <classname>EBox::Objects</classname>:
	  </para>
	  
	  <example>
	    <title>Añadiendo acciones para el registro</title>
	    <programlisting>
<![CDATA[
$self->{'actions'} = {};
$self->{'actions'}->{'add_object'} = __n('Added object {object}');
$self->{'actions'}->{'add_to_object'} =
        __n('Added {nname} ({ip}/{mask} [{mac}]) to object {object}');
$self->{'actions'}->{'remove_object'} = __n('Removed object {object}');
]]>
	    </programlisting>
	  </example>
		  
	  <para>
	    Para cada acción que quieras registrar, que debería ser todas que puedan
	    hacerse desde el interfaz web, deberás seguir estos pasos:
	  </para>
	  
	  <orderedlist>
	    <listitem>
	      <para>
		Añadir una marca de acción a la función, como:
	      </para>
	      <programlisting>
sub addObject # (description)
{
    #action: add_object
	      </programlisting>
	    </listitem>
	    <listitem>
	      <para>
		Llama los métodos <methodname>logAdminDeferred</methodname> or 
		<methodname>logAdminNow</methodname>. <methodname>logAdminDeferred</methodname>
		pone la acción en la base de datos con el campo <emphasis>confirmado</emphasis> a 
		<emphasis>falso</emphasis>, y debería ser llamado para acciones que no tengan
		lugar hasta que los cambios sean guardados, esto es, todo que se guarda
		en gconf. Cuando salves los cambios, las acciones se marcan como confirmadas,
		si reviertes los cambios estas acciones se borran.
	      </para>
	      <para>
		<method>logAdminNow</method> pone la acción en la base de datos con el campo
		<emphasis>confirmado</emphasis> a <emphasis>verdadero</emphasis>, y debería ser
		usado por acción que tengan efecto inmediato como cambiar la contraseña o
		añadir un usuario.
	      </para>
	      <para>
		Ambas funciones tiene la misma firma:
	      </para>
	      <programlisting>
logAdminDeferred(module,action,params)
logAdminNow(module,action,params)
	      </programlisting>
	      <para>
		Deberías llamarlo sólo cuando estés seguro que la acción ha tenido lugar, por
		ejemplo, para <methodname>addObject</methodname>.
	      </para>
	      <example>
		<title>Llamando al método <methodname>logAdminDeferred</methodname></title>
		<programlisting>
$self->set_string("$id/description", $desc);
logAdminDeferred('objects',"add_object","object=$desc");
return $id;
                </programlisting>
	      </example>
	      <para>
		Como se muestra, la base de datos guarda <emphasis>add_object</emphasis>, 
		<emphasis>object=objname"</emphasis>, el código mostrado crea la cadena
		que debería mostrarse y traducirse al lenguaje concreto.
	      </para>
	    </listitem>
	  </orderedlist>
	</section>

</chapter>

 


<!-- vim: ts=2 sw=2 tw=75
-->
<chapter id="ch-basic-api">

	<title>API Básica</title>

	<section id="sect-eboxglobal">
		<title><classname>EBox::Global</classname></title>

		<para>La clase <classname>EBox::Global</classname> ofrece varias
		funciones para la administración de módulos. Las funciones utilizadas
		más comúnmente son las que hacen referencia a la instanciación de
		módulos. <classname>EBox::Global</classname> funciona como una factoría
		de módulos, obtienes una instancia suya usando la función estática
		<methodname>getInstance</methodname> y después usar esa instancia para
		crear módulos. La factoría puede tener dos formas, una de sólo lectura
		y otra de lectura-escritura.</para>

		<para>Llamar a <methodname>getInstance</methodname> sin argumentos
		producirá una factoría de lectura-escritura, la cual crea módulos que
		le permiten hacer llamadas para cambiar la configuración. Un detalle
		muy importante de los módulos lectura-escritura es que devuelven la
		información de su última configuración, incluso si no se ha guardado
		todavía (lo que significa que podría ser revocada más tarde por el
		usuario). Esta idea es importante, ya que la configuración que nos
		ofrece el módulo lectura-escritura no debe ser tratada como
		definitiva, a no ser que el módulo no tenga cambios esperando a ser
		guardados. Puede ver si un módulo tiene cambios sin guardar llamando
		a la función <methodname>modIsChanged</methodname> en la clase
		<classname>EBox::Global</classname>.</para>

		<para>La idea subyacente en el comportamiento de los módulos
		lectura-escritura es tener un front-end para construir una
		configuración. Por ejemplo, si el usuario crea un nuevo objeto de red
		en el módulo objetos, el nuevo objeto mostrará instantáneamente la
		configuración del firewall y se podrá crear nuevas reglas del firewall
		que lo usen. Después de realizar todos los cambios deseados, el
		usuario guarda la configuración. Si decide cancelar los cambios que
		acaba de hacer, tanto el nuevo objeto como las reglas del firewall
		serán borradas.</para>

		<para>Hay una situación en la que no desea recoger la información que
		no ha sido guardada todavía.  Ésta es cuando se está generando el
		fichero de configuración de un demonio, configurando las reglas del
		firewall, configurando la dirección de un interfaz de red, o cualquier
		otra actividad que necesita la configuración real y definitiva. Esta
		situación se encuentra en los scripts del sistema (el script de
		arranque, trabajos de cron, etc). En estos casos necesita lo que se
		denominan módulos de sólo-lectura, que sólo ofrecen la información
		almacenada y no permiten hacer llamadas a funciones que cambiarían la
		configuración del módulo. Para obtener módulos de sólo-lectura
		necesita crear una instancia de <classname>EBox::Global</classname>
		configurando su parámetro <parameter>readonly</parameter> como
		<literal>true</literal>. Las instancias del módulo devueltas por una
		factoría creada de esta forma serán de sólo-lectura. Este script
		muestra como obtener una instancia del módulo squid y le pide que se
		reinicie:</para>

		<example>
			<title>Creando una instancia de un módulo de sólo-lectura</title>
			<programlisting><![CDATA[#!/usr/bin/perl

use strict;
use warnings;

use EBox;
use EBox::Global;
use Error qw(:try);

EBox::init();

my $global = EBox::Global->getInstance(1);
my $squid = $global->modInstance('squid');

try {
	$squid->restartService();
} catch EBox::Exceptions::Base with {
	print STDERR "El módulo Squid falló al reiniciarse.\n";
};]]></programlisting>
		</example>

		<para>Hay dos funciones que hacen más sencillo realizar dos tareas muy
		comunes: obtener una instancia de cada módulo y obtener una instancia
		de cada módulo que implemente alguna clase abstracta. Éstas son
		<methodname>modInstances</methodname> y
		<methodname>modInstancesOfType</methodname>. Usarlas es muy
		sencillo:</para>

		<example>
			<title>Funciones para instanciar más de un módulo</title>
			<programlisting><![CDATA[my $global = EBox::Global->getInstance(1);

# se reinician todos los módulos
foreach my $mod (@{$global->modInstances()}) {
	$mod->restartService();
}

# se reinician todos los módulos que implementen la clase NetworkObserver
foreach my $mod (@{$global->modInstancesOfType('EBox::NetworkObserver')}) {
	$mod->restartService();
}]]></programlisting>
		</example>

		<para>Reiniciar todos los módulos es todavía más sencillo que
		eso. <classname>EBox::Global</classname> nos provee de la función
		<methodname>restartAllModules</methodname> justamente para eso. Éste
		es uno de los métodos que realiza una operación en todos los módulos
		instalados:</para>

		<variablelist>

			<varlistentry>
				<term><methodname>restartAllModules</methodname></term>
				<listitem>
					<para>Llama a la función
					<methodname>restartService</methodname> de
					todos los módulos. Reinicia todos los
					servicios manejados por eBox. Los ficheros de
					configuración son regenerados cada vez que un
					servicio es reiniciado.</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>stopAllModules</methodname></term>
				<listitem>
					<para>Llama a la función
					<methodname>stopService</methodname> en todos
					los módulos, esto incluye la interfaz web de
					administración, por lo que hay que ser
					cauteloso.</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>revokeAllModules</methodname></term>
				<listitem>
					<para>Cancela los cambios de configuración que
					se han hecho en todos los módulos desde la
					última vez que la configuración se
					guardó.</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>saveAllModules</methodname></term>
				<listitem>
					<para>Guarda los cambios de la configuración
					en todos los módulos.</para>
				</listitem>
			</varlistentry>

		</variablelist>

	</section>

	<section id="sect-exceptions">
		<title>Excepciones</title>

		<para>El manejo de todos los errores en eBox está implementado con
		excepciones del estilo de Java. Éstas están provistas por el módulo de
		perl <classname>Error</classname>. Puede leer la documentación de perl
		para ese módulo para obtener una descripción detallada de cómo
		utilizar las excepciones en perl. Las excepciones de eBox están
		definidas en el espacio de nombres
		<classname>EBox::Exceptions</classname>.</para>

		<para>eBox provee una jerarquía de excepciones de la cual puede elegir
		la más apropiada para cada situación. Todas las excepciones de eBox
		heredan de una de estas dos:</para>

		<itemizedlist>
			<listitem>
				<para><classname>EBox::Exceptions::External</classname></para>
			</listitem>

			<listitem>
				<para><classname>EBox::Exceptions::Internal</classname></para>
			</listitem>
		</itemizedlist>

		<para>La diferencia entre estos dos tipos es que el usuario verá cuando
		una excepción no ha sido capturada. La plataforma del interfaz de
		usuario mostrará el mensaje contenido en la excepción sin alterarlo si
		la excepción es una de tipo externo. Debería usar excepciones externas
		para los errores introducidos por el usuario, como un error de
		sintaxis en una dirección IP dada por el interfaz de usuario al
		backend del módulo.</para>

		<para>Si la excepción es interna se registrará el error y se asumirá
		que algo falló internamente en eBox (un bug) o en el sistema en
		general. Cuando una excepción interna se captura por GUI el usuario
		verá un mensaje de error genérico. Cualquier excepción, interna o
		externa, puede ser utilizada internamente para otros propósitos,
		siempre que sea capturada antes de que recorra todo el camino hasta la
		GUI.</para>

		<para>Si no puede encontrar una excepción para ciertas condiciones de
		error, tiene dos opciones: crear una nueva clase de excepción,
		heredándola de <classname>EBox::Exceptions::External</classname> o
		<classname>EBox::Exceptions::Internal</classname>, o usar únicamente
		una de estas dos clases como excepciones genéricas:</para>

		<example>
			<title>Lanzando una excepción interna genérica</title>
			<programlisting><![CDATA[if ($foo_condition) {
	throw EBox::Exceptions::Internal('Algo ha pasado!!');
}]]></programlisting>
		</example>

		<para>Como puede ver, lanzar excepciones sigue una sintaxis muy
		similar a Java. Capturarlas también es muy similar:</para>

		<example>
			<title>Capturando una excepción</title>
			<programlisting><![CDATA[use Error qw(:try);

sub foo
{
	my $bar = shift;

	try {
		$bar->doSomething();
	} catch EBox::Exceptions::Base with {
		# no hace nada, sólo se ignora el error
	};
}]]></programlisting>
		</example>

		<para>Puede hacer lo que quiera dentro de la sección
		<quote>catch</quote>. Puede escribir varias secciones
		<quote>catch</quote> si necesita hacer diferentes cosas para
		diferentes tipos de excepción. Las secciones <quote>otherwise</quote>
		y <quote>finally</quote> también están permitidas. Para una
		explicación detallada sobre éstas, únicamente ejecute <command>perldoc
		Error</command>. Un detalle muy importante es no olvidar el punto y
		coma después de la última sección (el <quote>catch</quote> en el
		ejemplo). No hacerlo puede producir resultados inesperados, esto se
		debe a la magia negra que es utilizada en la implementación del
		try-catch en perl.</para>               
	</section>

	<section id="sect-validate">
		<title>Validación de datos</title>

		<para>Es muy importante que cada funcionalidad ofrecida por cada
		módulo valide sus datos de entrada correctamente. Todos los argumentos
		necesitan ser comprobados. Si esto no se hace, un módulo podría
		guardar valores sintácticamente incorrectos en su configuración, y el
		servicio subyacente se comportaría de una forma impredecible con el
		fichero de configuración generado por el módulo. La validación de
		datos también ayuda a encontrar errores en la GUI, y cualquier otro
		código que utilice el módulo.</para>
		
		<para>El módulo de perl <classname>EBox::Validate</classname> provee
		de una serie de funciones para validar diferentes tipos de
		datos. Todas estas funciones funcionan de la misma manera, su primer
		argumento es el valor que se va a comprobar. Devuelven
		<literal>true</literal> si el valor es correcto,
		<literal>undef</literal> si no lo es:</para>

		<example>
			<title>Usando funciones de validación de datos</title>
			<programlisting><![CDATA[use EBox::Validate qw(:all);

my $ip = '192.168.0.1';

unless (checkIP($ip))
	print STDERR "$ip no es válida.\n";
}]]></programlisting>
		</example>

		<para>Lo que hay que hacer normalmente si un argumento es incorrecto
		es lanzar una excepción. Y la mayor parte del tiempo el valor
		incorrecto será uno suministrado por el usuario. Por esta razón, todas
		las funciones en <classname>EBox::Validate</classname> nos suministran
		un mecanismo sencillo para lanzar excepciones del tipo
		<classname>EBox::External</classname>. Todo lo que es necesario hacer
		es pasarles un argumento más, con un nombre o descripción para el
		valor que está intentando comprobar. Si pasa ese argumento y la
		validación falla, se lanzará una excepción con un mensaje indicando el
		nombre del campo incorrecto:</para>

		<example>
			<title>Utilizando las funciones de validación de datos con
			gestión automática de errores</title>

			<programlisting><![CDATA[checkIP($ip, 'dirección IP ');
]]></programlisting>
		</example>

		<para>Si no quiere que se lance una excepción, o si quiere que se
		lance un tipo distinto, no pase el último argumento y gestione el
		error dentro de su código.</para>
	</section>

	<section id="sect-i18n">
		<title>i18n</title>

		<para>eBox utiliza <quote>gettext</quote>, la plataforma de
		internacionalización (i18n) del proyecto GNU, para permitir a los
		colaboradores traducir fácilmente el interfaz gráfico de eBox a su
		propio idioma.</para>

		<para>Esta sección describe la i18n de eBox tanto desde el punto de
		vista del desarrollador (reglas que deben seguirse para desarrollar un
		módulo traducible) como del traductor (cómo realizar una traducción de
		eBox a su idioma).</para>

		<section id="sect-i18n-developers">
			<title>i18n para desarrolladores</title>

			<para>Cada módulo de eBox tiene su propio dominio de texto para
			las cadenas que contiene, con un nombre construido a partir del
			nombre del propio módulo. Los módulos deben indicar tanto en el
			constructor del módulo como en cada uno de los CGI's el dominio de
			texto al que pertenecen, tal y como se indica en <xref
			linkend='sect-modconstructor'/> y <xref linkend='ex-cgi-domain'/>.
			</para>

			<para>Todos los ficheros que contengan cadenas traducibles, incluyendo
			las plantillas de Mason, deben incluir módulo perl
			<classname>EBox::Gettext</classname> y cualquier cadena que deba poder
			ser traducible debe ser marcada como tal, utilizando la función
			<function>__</function> tal y como se indica en el siguiente ejemplo:
			<programlisting>
print __("Hello world");
			</programlisting>
			Esto hará que el sistema de compilación de eBox sea capaz de detectar
			las cadenas traducibles y recopilarlas para su posterior traducción.
			</para>

			<para>Si la cadena debe incluir alguna variable no hay que concatenarla
			<programlisting>
print __("Edit ") . $group . __(" members"); #incorrecto
			</programlisting>
			ya que esto hace imposible una traducción correcta
			de la frase completa. La opción correcta es utilizar la función
			<function>__x</function>, una variante de la función
			<function>__</function> que permite incluir variables:
			<programlisting>
print __x("Edit {group} members", group => $group); #correcto
			</programlisting>
			de tal modo que el traductor puede incluir la variable
			<varname>group</varname> en el lugar apropiado de la frase.</para>

			<para>Si quieres marcar una cadena como traducible pero decidiendo
			no traducirla, deberías usar la función <methodname>__n</methodname>.
			Un ejemplo de uso es el siguiente:

			<example>
			  <title>Usando la función <methodname>__n</methodname></title>
			  <programlisting>
my $options = [__n('Foo'), __n('Bar'), __n('Foobaz') ]; # As many as you want
print __($options[$index]);
			  </programlisting>
			</example>

			<para>El ejemplo mostrado antes da la oportunidad al traductor
			de traducir únicamente la opción elegida dejando a las demás posibles
			opciones (normalmente un alto número) sin una traducción.</para>

			<para>Si se siguen correctamente estas reglas, el sistema de
			compilación de eBox generará automáticamente los ficheros PO
			de los módulos conteniendo todas las cadenas incluidas en los
			mismos. Estos ficheros podrán ser traducidos comodamente por los
			traductores, como se explica en la siguiente subsección.</para>

		</section>

		<section id="sect-i18n-translators">

			<title>i18n para traductores</title>

			<para>Al utilizar GNU gettext como plataforma de i18n, eBox utiliza
			el formato más utilizado para la traducción, los ficheros PO.
			Cada módulo de eBox cuenta con un fichero PO para cada uno de los
			idiomas disponibles. Un traductor sólo tiene que traducir las
			cadenas catalogadas en ese fichero para traducir completamente un
			módulo. En el caso de que se desee empezar la traducción para un
			nuevo idioma sólo es necesario solicitar un fichero PO para el nuevo
			idioma.</para>

      <para>Un fichero PO para un determinado idioma contiene cadenas de
      texto en el idioma original (inglés) junto a su traducción. Cada
			cadena puede encontrarse en tres posibles estados: traducida (si
			existe una traducción para la cadena), difusa o borrosa (si existe
			una traducción para la cadena, pero la cadena ha cambiado
			ligeramente) o sin traducir:
			<programlisting>
# cadena traducida
msgid "Name"
msgstr "Nombre"

# cadena borrosa
#, fuzzy
msgid "Interfaces"
msgstr "Interface"

#cadena sin traducir
msgid "External"
msgstr ""
			</programlisting>
			</para>

			<para>Si la cadena a traducir necesita incluir el valor de una
			variable al ser presentada en la interfaz de usuario, encontrará en
			el fichero PO una entrada similar a esta:
			<programlisting>
msgid "Edit {group} members"
			</programlisting>
			En este caso simplemente se debe reescribir la frase recolocando el
			nombre de la variable (entre llaves) en el lugar necesario, pero sin 
			ser traducido. La traducción correcta de la cadena en este caso
			sería:
			<programlisting>
msgstr "Editar miembros de {group}"
			</programlisting>
			</para>

			<para>Aunque es posible realizar la traducción del fichero PO
			utilizando cualquier editor capaz de editar ficheros utilizando
			codificación UTF-8, es muy recomendable usar alguna de las
			herramientas creadas específicamente para la traducción de ficheros
			PO, como por ejemplo <ulink
			url='http://i18n.kde.org/tools/kbabel/'>KBabel</ulink> (*nix) o
			<ulink url='http://www.poedit.org/'>poEdit</ulink> (multiplataforma).
			</para>

		</section>
  </section>

</chapter>

#!/usr/bin/perl
# Copyright (C) 2010-2012 Zentyal S.L.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use strict;
use warnings;

use EBox;
use EBox::Backup;
use EBox::Config;
use EBox::EBackup::DBRestore;
use EBox::EBackup::Password;
use EBox::EBackup::Subscribed;
use EBox::Gettext;
use EBox::Global;
use EBox::NetWrappers;
use EBox::RemoteServices::ProxyBackup;
use EBox::ServiceManager;
use EBox::Sudo;
use EBox::Exceptions::Command;
use EBox::Exceptions::EBackup::FileNotFoundInBackup;
use EBox::Exceptions::EBackup::BadSymmetricKey;
use Error qw(:try);
use Getopt::Long;
use POSIX 'setsid';
use Term::ReadKey;
use Date::Parse;
use DateTime;
use String::ShellQuote;
use YAML::XS;
use File::Basename;

use constant NTP_SERVER     => 'pool.ntp.org';
use constant CHANGE_HOSTNAME_SCRIPT => '/usr/share/zentyal/change-hostname';

my $usesX = 1; # flag to signal whether graphical environment is available

my $xauthCookie;
my $usage = 0;
my ($user, $password, $serverCN);
my $restoreLast = 0;
my @toRestoreCli = ();
my $restoreAllDomains;
my $noEncryption;
my $symmetricPassword = undef;
my $encryptKey = undef;
my $keyPassphrase;
my %forceCredentials = (username => undef, password => undef, server => undef, noCloudLogin => undef   );
my $error = 0;
my %filesMD5;
my @pendingMessages;

parseArgs();

$xauthCookie = _xauthCookie();

EBox::init();

if ($usesX) {
    zenityPrecondition();
}

_xauthEBox($xauthCookie);

my $metadata;
try {
    EBox::info("Starting restore-tool");
    clearTmpDir();
    createTmpDir();
    modPreConditions();
    setSystemDate();
    # Stop any interrupting process
    _stopInterruptingProcesses();

    my $basicInfo = getUserAndPasswordAndServers($user, $password, \%forceCredentials);
    my $credentials;
    my $date;

    while (not $date) {
        $credentials = getCredentials($basicInfo->{user},
                                      $basicInfo->{password},
                                      $basicInfo->{servers},
                                      $serverCN,
                                      \%forceCredentials
                                     );

        unless ( $credentials->{type} eq 'basic' ) {
            getEncryption(
                $credentials,
                undef,
                symmetricPassword => $symmetricPassword,
                encryptionKey     => $encryptKey,
                keyPassphrase     => $keyPassphrase,
                noEncryption      => $noEncryption,
               );
        }

        # Restore last backup for basic users always
        $restoreLast = ($restoreLast or ($credentials->{type} eq 'basic'));

        $date = askBackupDate($credentials, $restoreLast);

        if (not $date) {
            my $msg = __('No backups found in this server. Do you want to retry with a different one?');
            my $retry = $usesX ? _zenityQuestion($msg) : terminalQuestion($msg);
            if (not $retry) {
                exit 0;
            }
            next; # start again, retry
        }

        unless ( $credentials->{type} eq 'basic' ) {
            my $metadataPath = _downloadBackupMetadata($credentials, $date);
            $metadata = readMetadataFile($metadataPath);

            unless ( $metadata->{hasConfiguration} ) {
                my $msg = __('There is not configuration backup from this date. '
                             . 'Do you want to retry with another date?');
                my $retry = $usesX ? _zenityQuestion($msg) : terminalQuestion($msg);
                if (not $retry) {
                    exit(0);
                }
                undef($date);
                next; # Start all over again, retry
            }
        }
    }

    my $toRestore = getBackupDomainsToRestore($credentials,
                                              $metadata,
                                              $restoreAllDomains,
                                              \@toRestoreCli);
    _logStartProcess($credentials, $date, $toRestore);

    my $configBackup = _getConfigBackup($credentials, $metadata, $date);

    _installMissingModules($configBackup);

    takeFilesMD5();

    doRestore(credentials => $credentials,
              toRestore   => $toRestore,
              configBackup => $configBackup,
              date         => $date,
              metadata     => $metadata,
             );

    saveChanges();

    regenerateCaches();

    finishedMessages($credentials, $metadata);
    clearTmpDir(); # Comment this for debug purposes
} otherwise {
    my $ex = shift @_;
    fatal($ex);
    $error = 1;
} finally {
    EBox::Global->deleteFirst();
};

exit $error;

sub parseArgs
{
    my $correct = GetOptions(
            'usage|help' => \$usage,
            'user|username=s' => \$user,
            'password=s' => \$password,
            'server-cn=s'   => \$serverCN,
            'backup-domain=s' => \@toRestoreCli,
            'restore-all-domains' => \$restoreAllDomains,
            'x|gui!' => \$usesX,
            'last-date!' => \$restoreLast,
            'symmetric-password=s' => \$symmetricPassword,
            # TODO: Uncomment to enable gpg decrypt
            #'encryption-key=s'  => \$encryptKey,
            #'key-passphrase=s'   => \$keyPassphrase,
            'no-encryption+'     => \$noEncryption,
            'force-username=s'  => \$forceCredentials{username},
            'force-password=s'  => \$forceCredentials{password},
            'force-server=s'  => \$forceCredentials{server},
            'force-no-cloud-login' => \$forceCredentials{noCloudLogin},
            'force-type=s'           => \$forceCredentials{type},
            );

    if ($usage or (not $correct)) {
        usage();
    }

    my $cryptOptions = grep { $_ } ($encryptKey, $symmetricPassword, $noEncryption);
    if ($cryptOptions > 1) {
        die __x('You can only specify one of the encryption options: {sy}, {no}',
                sy  => '--symmetric-password',
                no  => '--no-encryption');
    }

    if (defined $forceCredentials{type}) {
        my $type = $forceCredentials{type};
        if (($type ne 'basic') and ($type ne 'subscribed')) {
            die __(q{--force-type should have as argument either 'basic' or 'subscribed'});
        }
    }

    if ($noEncryption) {
        $symmetricPassword = 0;
        $encryptKey = 0;
        $keyPassphrase = 0;
    }
}

sub zenityPrecondition
{
    system 'which zenity 1> /dev/null';
    if ($? != 0) {
        print __('Zenity package not found. Falling back to terminal mode') . "\n";
        $usesX = 0;
    }
}

sub usage
{
    print "restore-tool  [--user=username] [--password=password] [--server=serverCommonName] [--last-date] [--restore-all]\n";
    print "              [--backup-domain=domain1] [--backup-domain=domain2]  ... \n";
    print "              [--no-encryption|--symmetric-password=PASSWORD]\n";
    print "              [--no-x]\n";
    print "              [--force-username=username] [--force-password=password] [--force-server=server] [--force-type=basic|subscribed] [--force-no-cloud-login]\n";
    print "\n";
    print "\t --user=USERNAME        \t ";
    print __("User for the authentication") . "\n";
    print "\t --password=PASSWORD    \t ";
    print __('Password for the authentication. This password will be shown both '
             . 'in the command line and in the process list so only use this option '
             . 'when security is not a concern') . "\n";
    print "\t --server=SERVER        \t ";
    print __("Server from which its backup date the restore will be done") . "\n";
    print "\t --last-date            \t ";
    print __("Use the last backup done for the restore")  . "\n";
    print "\t --restore-all            \t ";
    print __("Restore all backup domains available")  . "\n";
    print "\t --backup-domain=DOMAIN \t ";
    print __("Backup domain to restore. It could be repeated several times") . "\n";
    print "\t--no-encryption|--symmetric-password=PASSWORD\n";
    print __('Check if we use the no encryption or a symmetric encryption with password '), "\n";
    print "\t --no-x                 \t ";
    print __("Do not use graphical interface") . "\n";
    print "\t --force-username       \n"; 
    print "\t --force-password       \n"; 
    print "\t --force-server         \n "; 
    print "\t --force-no-cloud-login \n "; 
    print "\t --force-type           \t "; 
    print __("Change parameters used to access the storage server") . "\n";

    exit 0;
}

sub tmpDir
{
    return '/var/lib/zentyal/tmp/zentyal-restore';
}

sub filesTmpDir
{
    return tmpDir() . '/files';
}

sub metaTmpDir
{
    return tmpDir() . '/meta';
}

sub modPreConditions
{
    my @mods = ('ebackup', 'remoteservices'); # add software when used
    foreach my $modName (@mods) {
        unless (EBox::Global->modExists($modName)) {
            fatal(__x('Module {mod} should be installed', mod => $modName));
        }

        my $mod = EBox::Global->modInstance($modName);
        if ($mod->isa('EBox::Module::Service')) {
            unless ($mod->configured()) {
                fatal(__x('Module {mod} should be configured', mod => $modName));
            }
        }
    }
}

sub setSystemDate
{
    my $cmd = 'ntpdate ' . NTP_SERVER;
    try {
        EBox::Sudo::root($cmd);
    } otherwise {
        warning(__('Could not automatically update system date and hour. If the system time is not correct, some restore operations could fail'));
    };
}

sub askServerCN
{
    my ($servers) = @_;
    my $serverCN;
    if ($usesX) {
        my @serversOrdered = sort map {
            $_->{company} . ' : ' . $_->{name}
        } @{ $servers  };
        $serverCN = _zenityList(__('Choose the server to restore'),
                                __('Server'),
                                  0, \@serversOrdered);
        ($serverCN) = $serverCN =~ m/ : ([a-z0-9\-]+)$/;
    } else {
        showServerList($servers);
        $serverCN = terminalPrompt(__("Server to restore: "));
    }

    _checkServerCN($serverCN, $servers);

    return $serverCN;
}

sub askDomainsToRestore
{
    my ($credentials, $metadata) = @_;

    my %availableDomains = %{ _backupDomainsAvailableByPrintableName($metadata) };

    my @domains;
    if ($usesX) {
        my @elements;
        while (my ($printableName, $name) = each %availableDomains) {
            if ($name eq 'filesIncludes') {
                push @elements, {
                                 item => $printableName,
                                 enabled => 0,
                                }
            } else {
                push @elements, $printableName;
            }
        }

        my $answer = _zenityList(__('Select backup domains to restore'),
                                 __('Backup domain'),
                                 1,
                                 \@elements,
                                 enabledByDefault => 1,
                                );
        @domains = @{ $answer };
    } else {
        my @availablePrintableNames = keys %availableDomains;
        my $printableList = join ', ', @availablePrintableNames;
        print __x('Backup domains available in the server {cn}: {l}',
                  cn => $credentials->{commonName},
                  l => $printableList);
        print "\n";
        my $unparsed = terminalPrompt("Backup domains to restore (comma separated): ");
        @domains =  split ',', $unparsed;
        foreach  (@domains) {
            $_ =~ s/^\s+//;
            $_ =~ s/\s+$//;
        }
    }

    # get domain name form printable name
    @domains = map {
        exists $availableDomains{$_} ? $availableDomains{$_} : ()
    } @domains;

    if (not @domains) {
        fatal(__('No backup domain selected to restore. Doing nothing'));
    }

    my %toRestore = map { $_ => 1 } @domains;

    return \%toRestore;
}

sub serverList
{
    my ($remoteServices, $user, $password)  = @_;

    my $msg = __('Retrieving registered servers list');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    my $list;
    try {
        $list = $remoteServices->serverList(user => $user,
                                            password => $password);
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };

    return $list;
}


sub _setupPasswords
{
    my ($credentials) = @_;

    my $encKey = '';
    my $symPasswd = '';
    if (exists $credentials->{encValue} and
         ($credentials->{encValue} ne 'disabled')) {
        if (exists $credentials->{encSelected}) {
            my $selected = $credentials->{encSelected};
            my $value    = $credentials->{encValue};
            if ($selected eq 'asymmetric') {
                $encKey = $value;
            } elsif ($selected eq 'symmetric') {
                $symPasswd = $value;
            }
        }
    }

    if ($symPasswd) {
        EBox::EBackup::Password::setSymmetricPassword($symPasswd, 1);
    }

    if ($encKey) {
        if (not $credentials->{keyPassphrase}) {
            fatal(__('No key passphrase'));
        }
        EBox::EBackup::Password::setGpgPassphrase($credentials->{keyPassphrase}, 1);
    }

    my $password = $credentials->{password};
    if (not defined $password) {
        fatal(__('No password in retrieved credentials'));
    }
    EBox::EBackup::Password::setPasswdFile($password, 1);
}


sub backupCredentials
{
    my %params = @_;
    my $remoteServices = delete $params{remoteServices};
    my $force          = delete $params{force};
    my $credentials;

    unless ($force->{noCloudLogin}) {
        $credentials = _credentialsFromCloud($remoteServices, %params);
    } else {
        $credentials = {};
    }

    if (not defined $credentials) {
        $credentials = {
            username => $params{username},
            password => $params{password},
            method   => 'scp',
            type     => 'basic',
        };
    } else {
        $credentials->{type} = 'subscribed';
    }

    foreach my $cred (qw(username password server type)) {
        if ($force->{$cred}) {
            $credentials->{$cred} = $force->{$cred};
        }
    }

    $credentials->{commonName} = $params{serverCN};

    $credentials->{confBackupDir} = EBox::EBackup::Subscribed::confBackupDir($credentials->{commonName});

    if (not exists $credentials->{method}) {
        $credentials->{method} = 'scp';
    }

    return $credentials;
}

sub _credentialsFromCloud
{
    my ($remoteServices, %params) = @_;

    my $credentials;
    my $msg = __('Retrieving account information');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    try {
        $credentials =
            $remoteServices->backupCredentials(
                    username   => $params{username},
                    password   => $params{password},
                    commonName => $params{serverCN},
                    force      => 1,
                    );
    } catch EBox::Exceptions::DataNotFound with  {
        $credentials = undef;
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };

    return $credentials;
}

sub addEncryptionToCredentials
{
    my ($credentials, %params) = @_;

    if ($credentials->{type} ne 'subscribed') {
        return $credentials;
    }

    if ($params{symmetricPassword}) {
        $credentials->{encSelected} = 'symmetric';
        $credentials->{encValue} = $params{symmetricPassword};
    } elsif ($params{encryptionKey}) {
        $credentials->{encSelected} = 'asymmetric';
        $credentials->{encValue} = $params{encryptionKey};
        $credentials->{keyPassphrase} = $params{keyPassphrase};
    } else {
        $credentials->{encSelected} = 'none';
        $credentials->{encValue} = 'disabled';
    }

    return $credentials;
}


sub showServerList
{
    my ($serverList) = @_;

    if (not @{ $serverList }) {
        fatal(__("No registered Zentyal Servers"));
    }

    my @ordered = sort @{ $serverList};

    print "\n";
    print __('Registered Zentyal Servers');
    print "\n--------------------------------------\n";
    foreach my $server (@ordered) {
        print $server, "\n";
    }

    print "\n";
}

sub doRestore
{
    my %params = @_;

    my $configBackup = $params{configBackup};
    my $credentials  = $params{credentials};
    my $date         = $params{date};
    my $metadata     = $params{metadata};
    my %toRestore    = %{ $params{toRestore} };

    # set hostname before restorign anything
    setHostname($metadata);

    my $restoreConfig = delete $toRestore{configuration};
    if ($restoreConfig) {
        restoreConfig($configBackup);

        if ( $credentials->{type} ne 'basic' ) {
            _installCloudPackages($configBackup); # install cloud packages need
                                                  # access to special repositories
                                                  # granted by remoteservices
        }
    }

    if ($credentials->{type} eq 'basic') {
        # basic subscriptions backups only store the configuration, so we have
        # finished
        return;
    }

    if (keys %toRestore == 0) {
        # only requested configuration restore, finished
        return;
    }

    _downloadBackupData($credentials, $date, \%toRestore, $metadata);

    my $ebackup = EBox::Global->modInstance('ebackup');

    my $urlParams   = _remoteUrlParamsFromCredentials($credentials, 'data');
    if ($toRestore{filesIncludes}) {
        _restoreAllFiles($ebackup, $date);
    } else {
        _restoreBackupDomainsFiles($ebackup, $date, \%toRestore);
    }


    if ($toRestore{logs}) {
        _restoreLogs($date);
    }
}


# Restore the files whose source are backup domains
sub _restoreBackupDomainsFiles
{
    my ($ebackup, $date, $toRestore) = @_;

    my $msg = __('Restoring files');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    try {
        # restore backup domains

        foreach my $mod (@{ EBox::Global->modInstances() }) {
            $mod->can('backupDomainsFileSelection') or next;

            my $selection = $mod->backupDomainsFileSelection(%{ $toRestore } );
            if ((not defined $selection) or (keys %{ $selection} == 0)) {
                next;
            }

            foreach my $file (@{ $selection->{'includes'} }) {
                $file =~ s{/+$}{};
                my $srcFile = _fileFromBackup($file);
                my $dstFile = $file;

                try {
                    _restoreFile($srcFile, $dstFile);
                } otherwise {
                    my $ex = shift;
                    my $msg = __x('Cannot restore file {file} requested by backup domains. Reason: {reason}',
                                  file => $file,
                                  reason => "$ex",
                                 );
                    EBox::warn($msg);
                };
            }
        }
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub _restoreAllFiles
{
    my ($ebackup, $date) = @_;
    my $srcDir = filesTmpDir();

   # files and dirs that shouldnt be restored
    my @notRestoreFiles = (
        $0, # this  file itself

        '/boot',
        '/proc',
        '/dev',
        '/sys',
        '/lib',
        '/media',
        '/mnt',
        '/cdrom',
        '/floppy',
        # perl and zentyal modules
        '/usr/bin/perl',
        '/usr/share/perl*',
        '/usr/share/zentyal*',
        # zentyal home
        EBox::Config::home(),
        # zentyal /etc (restored in configuration restore)
        EBox::Config::etc(),
        # zenity
        '/usr/bin/zenity',
        # lib directory
        '/usr/lib',
        # sudo zentyal file
        '/etc/sudoers.d/ebox',
        # extra backup data dir is of no use
        $ebackup->extraDataDir(),
    );

    # no wildcards will be expanded in @renameFiles
    my @renameFiles = (
        '/var/log',
    );

    my $msg = __('Restoring all backed-up files');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    # regular files in / are not restored anyway they should be links to
    # /boot that should not be touched
    try {
        foreach my $file (@notRestoreFiles) {
            $file = $srcDir . '/' . $file;
            EBox::Sudo::silentRoot("ls $file");
            if ($? == 0) {
                EBox::info("This file(s) is in the backup but either  is not safe to automatically restore or is superfluous, skipping it: $file");
                EBox::Sudo::root("rm -rf $file");
            }
        }

        foreach my $file (@renameFiles) {
            $file = $srcDir . '/' . $file;
            EBox::Sudo::silentRoot("ls '$file'");
            if ($? == 0) {
                my $newName = $file . '.from-backup';
                EBox::info("The file $file will be restored as $newName");
                try {
                    EBox::Sudo::root("mv -b '$file' '$newName'");
                } otherwise {
                 EBox::error("The file $file cannot be restored as $newName. We will skip it");
                 EBox::Sudo::root("rm -rf $file");
             };
            }
        }

        my @dirsInBackup = @{ EBox::Sudo::root("find $srcDir -type d -maxdepth 1") };
        foreach my $dir (@dirsInBackup) {
            chomp $dir;
            my $toRestore = $dir;
            if ($toRestore eq $srcDir) {
                next;
            }

            $toRestore =~ s{^/*$srcDir}{};
            _restoreFile($dir, $toRestore);
        }
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub _restoreFile
{
    my ($src, $dst) = @_;

    EBox::debug("About to try to restore $dst from $src");
    if (not EBox::Sudo::fileTest('-e', $src)) {
        EBox::error("Cannot restore $dst. Source path $src does not exists");
        return;
    }

    my $srcArg = $src;
    if (EBox::Sudo::fileTest('-e', $dst)) {
        if (EBox::Sudo::fileTest('-d' , $dst)) {
            if (not EBox::Sudo::fileTest('-d', $src)) {
                error(__x('Could not restore {dst}, it already exists and it is not a directory',
                          dst => $dst),
                      noBlocking => 1,
                     );
                return;
            }

            $srcArg = "$src/*";
            my $srcEmpty;
            try {
                EBox::Sudo::root("ls $srcArg");
            } otherwise {
                $srcEmpty = 1;
            };
            if ($srcEmpty) {
                # no files to copy to already existent directory..
                EBox::debug("No files to restore $dst; $src is empty");
                return;
            }
        }
    }

    my $dstDir = File::Basename::dirname($dst);
    if ($dstDir ne '/') {
       my $dstDirExists = EBox::Sudo::fileTest('-e', $dstDir);
       if (not $dstDirExists) {
           my $srcDir = File::Basename::dirname($src);
           _restoreDirTree($srcDir, $dstDir);
       }
    }

    my $restoreCmd = "cp -rpf $srcArg $dst";
    try {
        EBox::Sudo::root($restoreCmd);
    } otherwise {
        my $ex = shift;
        EBox::error("Restore file command failed $restoreCmd: $ex");
        error(__x(
                 'Error restoring file or directory {dst}. We will try to continue the restore',
                 dst => $dst,
                ),
              noBlocking => 1,
             );
    };
}

sub _restoreDirTree
{
     my ($src, $dst) = @_;
     my @dirs = ( [$src, $dst] );

     my $newDst = File::Basename::dirname($dst);
     my $newSrc = $src;
     while (($newDst ne '/') and not  EBox::Sudo::fileTest('-e', $newDst)) {
         my $newSrc = File::Basename::dirname($src);
         unshift @dirs, [$newSrc, $newDst];
         $newDst  = File::Basename::dirname($newSrc);
     }

     foreach  my $dirPair (@dirs) {
         my ($srcDir, $dstDir)  = @{ $dirPair };
         try {
             EBox::Sudo::root("mkdir $dstDir");
             EBox::Sudo::root("chmod --reference=$srcDir $dstDir");
             EBox::Sudo::root("chown --reference=$srcDir $dstDir");
         } catch EBox::Exceptions::Sudo::Command with {
             my $ex = shift;
             my $msg = __x('Error restoring directory {d}. This could make fail some files or domains restore processes. Error {e}',
                           d => $dstDir,
                           e => join '', @{ $ex->error }
                          );
             warning($msg, noBlocking => 1);
         };
     }
}

# sliced-mode is not supported
sub _restoreLogs
{
    my ($date) = @_;

    my $dir = EBox::EBackup::DBRestore::backupDir();
    my $dumpFile =  $dir . '/' . EBox::EBackup::DBRestore::dumpBasename() . '.dump';
    my $src = _fileFromBackup($dumpFile);


    if (not  EBox::Sudo::fileTest('-r', $src) ) {
        warning(__('Backup log data not found in the files from the backup, log database will not be restored'),
                noBlocking => 1
               );
        return;
    }

    _restoreFile($src, $dumpFile);

    my $msg = __('Restoring log database');
    my $pulsatePid = _showUnanticipatedProgress($msg);
    try {
        EBox::EBackup::DBRestore::restoreEBoxLogsFromDir($dir, $date);
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub restoreConfig
{
    my ($configBackup) = @_;

    preRestoreConfigChecks($configBackup);

    my $progressIndicator =
        EBox::Backup->prepareRestoreBackup($configBackup,
                                           revokeAllOnModuleFail => 0,
                                           continueOnModuleFail  => 1
                                          );

    my $retValue = progress($progressIndicator, __('Restoring configuration backup'));
    if ($retValue != 0) {
        my $errorMsg = $progressIndicator->errorMsg();
        if ($errorMsg) {
            my $msg = $errorMsg . "\n";
            $msg .= __('The configuration restore failed. We will continue the process to try to restore as much as possible but your system will need manual tweaking');
            error($msg);
            return;
        } else {
            EBox::warn("Progress indicator for restoreConfig does not specify any error but has returned the following value: $retValue.");
        }
    }

    postRestoreConfigMangling();
}

sub preRestoreConfigChecks
{
    my ($configBackup) = @_;

    my $msg = __('Checking configuration compability');
    my $unanticipatedProgress = _showUnanticipatedProgress($msg);

    # check that interfaces referenced in network exist
    # XXX try to mangle this if possible to allow restore
    my $dir;
    try {
        $dir = EBox::Backup->_unpackAndVerify($configBackup);
        EBox::Backup->_unpackModulesRestoreData($dir);

        _preRestoreNetworkCheck($dir);
    } finally {
        system "rm -rf $dir";
        _finishUnanticipatedProgress($unanticipatedProgress);
    };
}


sub _preRestoreNetworkCheck
{
    my ($dir) = @_;

    my $confBakFile = "$dir/eboxbackup/network.bak/network.bak";
    if (not -r $confBakFile) {
        EBox::error("Cannot found data for network module, Skipping network pre-restore check");
        return;
    }

    my @enabledIfaces;

    # Open the config
    my @yaml = YAML::XS::LoadFile($confBakFile);
    foreach my $spec (@yaml) {
        my $iface;
        if ($spec->{key} =~ m{^/ebox/modules/network/interfaces/(.*?)/method$}) {
            $iface = $1;
        }  else {
            # not interested in this key
            next;
        }

        # no enabled, safe to ignore
        next if ($spec->{value} eq 'notset');

        push @enabledIfaces, $iface;
    }

    my @missing = grep {
        not EBox::NetWrappers::iface_exists($_)
    } @enabledIfaces;

    if (@missing) {
        my $msg = __x('Cannot restore backup because there are less interfaces than there are available. The missing interfaces are: {missing}',
                      missing => join ',', @missing
                     );
        fatal($msg);
    }
}

sub _installMissingModules
{
    my ($configBackup) = @_;

    my %modulesInBackup = map { $_ => 1 } @{ EBox::Backup->_modulesInBackup($configBackup) };
    my %modulesToConfigure  = %modulesInBackup;

    foreach my $modName ( @{ EBox::Global->modNames() }) {
        delete $modulesInBackup{$modName};
        my $mod = EBox::Global->modInstance($modName);
        if ((not $mod->isa('EBox::Module::Service')) or
             $mod->configured()) {
            delete $modulesToConfigure{$modName};
        }
    }

    my @missingModules = keys %modulesInBackup;
    if (@missingModules) {
        _updateDebPackagesList();
        EBox::info("Missing modules to recover the configuration: @missingModules");
        _installDebPackages(@missingModules);
    }

    my @unconfModules = keys %modulesToConfigure;
    if (@unconfModules) {
        EBox::info("Modules to configure: @unconfModules");
        _configureModules(@unconfModules);
    }
}


sub _updateDebPackagesList
{
    my ($msg) = @_;

    if (not $msg) {
        $msg = __('Updating software package lists');
    }

    my $pulsatePid = _showUnanticipatedProgress($msg);

    try {
        EBox::Sudo::root('apt-get update -q');
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub _installDebPackages
{
    my @modules = @_;

    my @packages;
    foreach my $mod (@modules) {
        next if EBox::Global->modExists($mod);

        # cloud-prof is a special case
        next if ($mod eq 'cloud-prof');

        push (@packages, "zentyal-$mod");
    }

    if (@packages) {
        my $msg = __('Installing Zentyal components and their dependencies');
        _aptInstall(\@packages, $msg);
    }

    # TODO: assure that modules are loaded and retrievable by EBox::Global->modInstance
}

sub _aptInstall
{
    my ($packages_r, $msg) = @_;

    my @packages = @{ $packages_r };

    my $software = EBox::Global->modInstance('software');
    my $progressIndicator = $software->installPkgs(@packages);
    my $retValue = progress($progressIndicator,
                         __('Installing missing modules...'));
    if ($retValue != 0) {
        my $errorMsg = $progressIndicator->errorMsg();
        my $msg;

        if ($errorMsg) {
            my $msg = __x('Error installing packages: {err}. The backup will continue but it would not able to recover any configuration  whcih depends on the missing packages',
                          err => "\n$errorMsg\n");
            error($msg, noBlocking => 1);
            return;
        } else {
            EBox::warn("Progress indicator for _aptInstall does not specify any error but has returned the following value: $retValue.");
        }
    }
}

sub _installCloudPackages
{
    my ($confBackup) = @_;

    my $remoteservices = EBox::Global->modInstance('remoteservices');
    unless ($remoteservices->eBoxSubscribed()) {
        return;
    }

    my $openvpn = EBox::Global->modInstance('openvpn');
    my $loaded = _loadSubscriptionBundle($remoteservices, $openvpn);
    unless ($loaded) {
        # could not install this packages without bundle
        return;
    }

    my @toInstall;

    my %cloudPackages = (
                         'ebox-cloud-prof',
                         'zentyal-security-updates',
                        );

    my $installedPackages = _debPackagesInBackup($confBackup);
    foreach my $package (@{ $installedPackages }) {
        if (exists $cloudPackages{$package}) {
            push @toInstall, $package;
            delete $cloudPackages{$package};
            if (keys %cloudPackages == 0) {
                last;
            }
        }
    }

    unless (@toInstall) {
        return;
    }

    _updateDebPackagesList(__('Updating package list to allow access to exclusive Zentyal Cloud packages'));

    my $msg = __('Install cloud packages');
    _aptInstall(\@toInstall, $msg);

    # No configure modules stage required because:
    # ebox-cloud-prof no needs configuration but only restoring
    # zentyal-security-updates is not a zentyal module
    my $cloudProfInstalled = grep { $_ eq 'cloud-prof'  } @toInstall;
    if ($cloudProfInstalled) {
        EBox::Backup->restoreBackup($confBackup, revokeAllOnModuleFail => 0,
                                    modsToRestore => [ 'cloud-prof' ]);
    }
}


sub _loadSubscriptionBundle
{
    my ($remoteservices, $openvpn) = @_;

    my $msg = __('Downloading subscription data');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    my $res;
    try {
        $openvpn->restartService();
        $remoteservices->restartService(); # to assure connection
        $res = $remoteservices->reloadBundle('force');
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };

    if ($res == 1) {
        # success!
        return 1;
    }

    if ($res == 0) {
        warning(__('Connection error when retrieving subscription bundle. Zentyal Cloud exclusive packages will not be installed'),
                 noBlocking => 1
                );

    } elsif ($res == 2) {
        warning(__('Cannot retrieve bundle because either installed ' .
                   'zentyal-remoteservices is outdated or only outdated ' .
                   'bundle is available in the cloud. Zentyal Cloud  ' .
                   'exclusive packages will not be installed'),
                noBlocking => 1,
               );
    } else {
        warning(__('Unknown error retrieving subscription bundle. Zentyal Cloud exclusive packages will not be installed'),
                noBlocking => 1,
               );
    }

    return 0;
}

sub _debPackagesInBackup
{
    my ($confBackup) = @_;

    my @packages;
    my $tmpDir = EBox::Backup->_unpackArchive($confBackup, 'debpackages');
    try {
        my $file = "$tmpDir/eboxbackup/debpackages";
        open (my $FH, "<", $file) or
            die "Error opening installed packages file $!";
        while (my $line = <$FH>) {
            # lines are like: ii apache2.2-common 2.2.14-1 Apache HTTP Server
            if ($line =~ m/\Aii\s+(.*?)\s/) {
                push @packages, $1;
            }
        }
        close $FH or
            die "Error closing isntalled packages file: $!";
    } finally {
        system "rm -rf $tmpDir";
    };

    return \@packages;
}


sub _configureModules
{
    my @modulesToConfigure = @_;

    unless (@modulesToConfigure) {
        return;
    }

    my %toConfigure = map { $_ => 1 } @modulesToConfigure;

    my $mgr = EBox::ServiceManager->new();
    my @orderedMods = @{$mgr->_dependencyTree()};

    my $PROGRESS_BAR;
    $usesX and
      local $SIG{PIPE} = 'IGNORE';

    my $pid;
    if ($usesX) {
        my $msg = __('Configuring modules');
        my $cmd = _zenityProgress($msg);
        $pid = open($PROGRESS_BAR, "|-");
        if ( $pid == 0 ) {
            # Child code
            exec { $cmd->[0] } @{$cmd};
            exit(2);
        }
    } else {
        print "\n";
    }

    my $i = 0;
    my $percent;
    foreach my $name (@orderedMods) {
        $i += 1;
        next unless (exists $toConfigure{$name});

        my $percent = ($i/(scalar @orderedMods)) * 100;
        $percent = sprintf("%i", $percent);

        if ($PROGRESS_BAR) {
            print $PROGRESS_BAR $percent . "\n" or
                _zenityProgressFail($!, $?);
            print $PROGRESS_BAR '#' . __x('Configuring modules: Current module {mod}', mod => $name) . "\n"
              or _zenityProgressFail($!, $?);
        } elsif (not $usesX) {
            print "\r";
            my $msg =  __x('Configuring modules {p} done. Current module {mod}',
                           p => "$percent%", mod => $name);
            print $msg;
            print "\n";
        }

        print "About to configure $name\n"; # DDDD
        my $module = EBox::Global->modInstance($name);
        $module->setInstalled();
        $module->setConfigured(1);
        $mgr->updateModuleDigests($name);

        try {
            $module->enableActions();
        } otherwise {
            my ($ex) = @_;
            my $err = $ex->text();
            $module->setConfigured(0);
            $module->enableService(0);
            my $msg = __x('Failed to configure module {name}: {err}. This could affect to the restore of other modules',
                          name => $module->name(),
                          err  => $err,
                         );
            warning($msg, noBlocking => 1);
        };

        $mgr->updateModuleDigests($name); # in ConfigureModuleController this is
            # call bef and after the enableActions
        print "Finished configuring $name\n"; # DDDD
    }

    if ($PROGRESS_BAR) {
        print $PROGRESS_BAR "100\n" or
            _zenityProgressFail($!, $?);
        close $PROGRESS_BAR or
            _zenityProgressFail($!, $?);

        if ($pid) {
            waitpid($pid, 0);
        }
    }

    my $saveChangesMsg = __('Finishing new modules configuration');
    print "Saving changes for new modules\n"; # DDD
    saveChanges($saveChangesMsg);
}


sub postRestoreConfigMangling
{
     # XXX here we will fix config items

}

# Stop any interrupting processes if required
sub _stopInterruptingProcesses
{
    my @interruptingModules = qw(events openvpn);
    try {
        my $gl = EBox::Global->getInstance(1);
        foreach my $mod (@interruptingModules) {
            if ( $gl->modExists($mod) ) {
                my $modInstance = $gl->modInstance($mod);
                $modInstance->stopService();
            }
        }
    } otherwise { };
}

sub _createFilesTmpDir
{
    my $filesTmpDir = filesTmpDir();
    if (not -d $filesTmpDir) {
        mkdir $filesTmpDir or
            throw EBox::Exceptions::Internal("Cannot create directory $filesTmpDir: $!");
    }

    my @dirsToCreate = (
        '/bin',
        '/boot',
        '/etc',
        '/home',
        '/lib',
        '/opt',
        '/root',
        '/sbin',
        '/selinux',
        '/srv',
        '/sys',
        '/tmp',

        '/usr/bin',
        '/usr/etc',
        '/usr/games',
        '/usr/include',
        '/usr/lib',
        '/usr/lib32',
        '/usr/lib64',
        '/usr/local',
        '/usr/sbin',
        '/usr/share',
        '/usr/src',

        '/var/cache',
        '/var/spool',
    );

    my @cmds;
    foreach my $dir (@dirsToCreate) {
        my $d = $filesTmpDir . $dir;
        push (@cmds, "mkdir -p --mode=755 $d");
    }
    EBox::Sudo::root(@cmds);

    return $filesTmpDir;
}

sub _downloadBackupMetadata
{
    my ($credentials, $date) = @_;
    my $basic = $credentials->{type} eq 'basic';
    if ($basic) {
        return;
    }

    my $dstDir = metaTmpDir() ;
    if (not -d $dstDir) {
        mkdir $dstDir;
    }

    my $msg = __('Downloading backup metadata...');

    my $pulsatePid = _showUnanticipatedProgress($msg);
    try {
        EBox::EBackup::Subscribed::downloadDRMetadata($credentials, $date, $dstDir);
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub _fullDownload
{
    my ($toRestore, $metadata) = @_;
    my $fullDownload = 0;
    if ($metadata->{version} < 2) {
        # don't have size metadata so we use full
        return 1;
    }

    if ($toRestore->{filesIncludes}) {
        $fullDownload = 1;
    } else {
        my $total = 0;
        my $sizeToRestore;
        foreach my $domain (keys %{ $metadata->{backupDomains} }) {
            if (exists $metadata->{backupDomains}->{$domain}->{size}) {
                my $size = $metadata->{backupDomains}->{$domain}->{size};
                $total += $size;
                if ($toRestore->{$domain}) {
                    $sizeToRestore += $size;
                }
            }
        }
        my $threshold = $total/3;
        if (defined $sizeToRestore) {
            $fullDownload =  ($sizeToRestore >= $threshold);
        } else {
            # play safe
            $fullDownload = 1;
        }
    }

    return $fullDownload;
}


sub _pathsToRestoreByDomain
{
    my ($metadata, %toRestore) = @_;

    my $ebackup = EBox::Global->getInstance()->modInstance('ebackup');
    my %pathsByDomain;
    foreach my $domain (keys %toRestore ) {
        my $extraData =  $metadata->{backupDomains}->{$domain}->{extraDataDump};
        my $selections = $ebackup->_rawModulesBackupDomainsFileSelections($domain => 1);
        my @paths = map {
                if (exists $_->{includes}) {
                    @{  $_->{includes} };
                } else {
                    ()
                }
            } @{  $selections };
        if ($extraData) {
            push @paths, $ebackup->extraDataDir() . '/' . $domain;
        }

        $pathsByDomain{$domain} = \@paths;
    }

    return \%pathsByDomain;
}


sub _downloadBackupData
{
    my ($credentials, $date, $toRestore, $metadata) = @_;
    my $basic = $credentials->{type} eq 'basic';
    if ($basic) {
        return;
    }

    my $urlParams = _remoteUrlParamsFromCredentials($credentials, 'data');

    my $dstDir = _createFilesTmpDir();

    if (_fullDownload($toRestore, $metadata)) {
        my $msg = __('Downloading the backup data');
        # restore all files, this is done to sepepd-up the process
        _downloadDuplicityFiles($urlParams, $date, '/',  $dstDir, $msg);
    } else {
        my %downloaded;
        my $pathsByDomain = _pathsToRestoreByDomain($metadata, %{ $toRestore });
        foreach my $domain (keys %{ $toRestore }) {
            my $printableName =  $metadata->{backupDomains}->{$domain}->{printableName};
            $printableName or
                $printableName = $domain;

            my @srcs = sort @{  $pathsByDomain->{$domain} };
            foreach my $src (@srcs) {
                if ($downloaded{$src}) {
                    next;
                }
                $downloaded{$src} = 1;

                my $msg =  __x('Downloading  {src} backup data for {dom}',
                               src => $src,
                               dom => $printableName);

                # adjust src and dst if needed
                my $dst = $dstDir . '/' . $src;
                while (($src ne '/') and not EBox::Sudo::fileTest('-d',  File::Basename::dirname($dst))) {
                    $src = File::Basename::dirname($src);
                    $dst = $dstDir . '/' . $src;
                }

                try {
                    _downloadDuplicityFiles($urlParams, $date, $src,  $dst, $msg);
                } otherwise {
                    my $errorMsg = __x('Error downloading data for backup domain: {dom}. The domain will not be fully restored',
                                       dom => $printableName,
                                 );
                    warning($errorMsg);
                };
            }
         }
    }
}

sub _downloadConfigurationBackupFromFilesArchive
{
    my ($credentials, $date, $file, $dst, $msg) = @_;

    my $basic = $credentials->{type} eq 'basic';
    if ($basic) {
        return;
    }

    $msg or
        $msg = __('Downloading the backup configuration');
    my $urlParams = _remoteUrlParamsFromCredentials($credentials, 'data');

    _downloadDuplicityFiles($urlParams, $date, $file, $dst, $msg);
}


sub _downloadDuplicityFiles
{
    my ($urlParams, $date, $src, $dstDir, $msg) = @_;

    EBox::info($msg);
    EBox::info("Restoring $src to $dstDir ");

    my $done = 0;
    while (not $done) {
        my $pulsatePid = _showUnanticipatedProgress($msg);
        try {
            my $ebackup = EBox::Global->getInstance()->modInstance('ebackup');
            $ebackup->restoreFile($src, $date, $dstDir, $urlParams);
            $done = 1;
        } catch EBox::Exceptions::EBackup::BadSymmetricKey with {
            _retrySymmKey($urlParams);            
        }otherwise {
            my $ex = shift @_;
            EBox::error("Error restoring file $src to $dstDir: $ex");
            $ex->throw();
        } finally {
            _finishUnanticipatedProgress($pulsatePid);
        };
    }
}

sub _fileFromBackup
{
    my ($file) = @_;
    return filesTmpDir() . '/' . $file;
}

sub _getConfigBackup
{
    my ($credentials, $metadata, $date) = @_;

    my $dstFile = tmpDir() . '/backup-config';

    my $basic = $credentials->{type} eq 'basic';
    if ($basic) {
        my $msg =  __('Downloading configuration');;
        my $pulsatePid = _showUnanticipatedProgress($msg);
        try {
            _downloadBasicConfigurationBackup($credentials, $date, $dstFile);
        } finally {
            _finishUnanticipatedProgress($pulsatePid);
        };

        return $dstFile;
    }

    if ($metadata->{version} >= 2) {
        my $bakFile;      
        my $done = 0;
        while (not $done) {
            try {
                $bakFile = EBox::EBackup::Subscribed::downloadConfigurationBackup($credentials, $date, $dstFile);
                $done = 1;
            } catch EBox::Exceptions::EBackup::BadSymmetricKey with {
                _retrySymmKey(_remoteUrlParamsFromCredentials($credentials));
            };
        }

        if ($bakFile and (-e $bakFile)) {
            return $bakFile;
        } else {
            fatal("Cannot found stored configuration fire in cloud");
        }
    }

    # XXX version 1 compability and fallback. Remove in the future
    my $ebackup = EBox::Global->modInstance('ebackup');
    my $backupFile =  $ebackup->includedConfigBackupPath();
    try {
        _downloadConfigurationBackupFromFilesArchive($credentials, $date, $backupFile, $dstFile);
    } catch EBox::Exceptions::EBackup::FileNotFoundInBackup with {
        my ($ex) = @_;
        if ($ex->file() eq $backupFile ) {
            # check if we are using a 2.0, trying to download a 2.0
            # configuration fule
            $backupFile =~ s/zentyal/ebox/g;
            try {
                _downloadConfigurationBackupFromFilesArchive($credentials, $date, $backupFile, $dstFile, __('Looking for a version 2.0.X backup'));
                fatal("You are likely trying to restore a backup done in a version 2.0.X; please retry with a 2.0.X installer", 1);
            } otherwise {
                # backup conf for 2.0 not foud, throw original excpetion
                $ex->throw(); 
            };
        } else {
            $ex->throw(); # no fallback, we rethrow the exception
        }
    };    

    return $dstFile;
}

sub askBackupDate
{
    my ($credentials, $restoreLast) = @_;

    if ($credentials->{type} eq 'basic') {
        return _basicBackupDate($credentials, $restoreLast);
    }

    # extractions of date could take a long time, maybe we can put a progress
    # widget there
    my $commonName = $credentials->{commonName};
    my $ebackup = EBox::Global->modInstance('ebackup');

    my $msg = __('Retrieving backup collection status ...');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    my @dates;
    my $lastDate;
    my $fail = 0;
    try {
        my $urlParams = _remoteUrlParamsFromCredentials($credentials, 'data');
        if ($restoreLast) {
            $lastDate= $ebackup->lastBackupDate($urlParams);
        } else {
            my $status = $ebackup->remoteStatus($urlParams);
            my %times = map { str2time($_->{date}) => $_->{date} } @{$status};
            my @sortDates = sort { $b <=> $a } keys(%times);
            @dates = map { $times{$_}; } @sortDates;
        }
    } otherwise {
        my $ex = shift;
        warning($ex);
        $fail = 1;
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };

    if ($fail) {
        return undef;
    }

    if ($lastDate) {
        print __x('Last backup date was: {date}', date => $lastDate) . "\n";
        return $lastDate;
    }

    if (not @dates) {
        # fatal(__x(
        #           'No backups found for server {server}',
        #           server => $credentials->{commonName}
        #          )
        #      );
        return undef;
    }

    return _backupDateInput($commonName, \@dates);
}

sub _basicBackupDate
{
    my ($credentials, $restoreLast) = @_;
    my $remoteBackup = EBox::RemoteServices::ProxyBackup->new(
                                          user => $credentials->{username},
                                          password => $credentials->{password},
                                                             );
    my $commonName = $credentials->{commonName};
    my $allBackups = $remoteBackup->listRemoteBackups();
    if (not exists $allBackups->{$commonName}) {
        warning(__x('No automatic configuration backups were made for the server {s}',
                  s => $commonName
                 )
            );
    }

    my $backups = $allBackups->{$commonName};
    if ($restoreLast) {
        return _lastBasicBackupDate($backups);
    }

    my @dates = map {
        $_->{Date}
    } values %{ $backups };

    return _backupDateInput($commonName, \@dates);
}


sub _lastBasicBackupDate
{
    my ($backups) = @_;

    my $lastDate;
    my $lastDateStr;
    while (my ($name, $attrs) = each %{ $backups }) {
        my ($dateStr) = split '\+', $attrs->{Date};
        my $date = DateTime->from_epoch(epoch => str2time($dateStr));

        if ((not defined $lastDate) or ($date > $lastDate)) {
            $lastDate = $date;
            $lastDateStr = $attrs->{Date};
        }
    }

    print __x('Last backup date was: {date}', date => $lastDateStr) . "\n";
    return $lastDateStr;
}

sub _backupDateInput
{
    my ($commonName, $dates) = @_;
    my $chosen;
    if ($usesX) {
        # first date in the list enabled
        my $firstDate = $dates->[0];
        $dates->[0] = {
            item => $firstDate,
            enabled => 1,
        };

        $chosen = _zenityList(__x('Choose date to restore the backup from server {cn}',
                                  cn => $commonName
                                 ),
                                __('Date'),
                                  0, $dates);
    } else {
        $chosen = _terminalDateInput($commonName, $dates);
    }

    return $chosen;
}


sub _downloadBasicConfigurationBackup
{
    my ($credentials, $date, $dstFile) = @_;
    my $remoteBackup = EBox::RemoteServices::ProxyBackup->new(
                                          user => $credentials->{username},
                                          password => $credentials->{password},
                                                             );
    my $commonName = $credentials->{commonName};
    my $allBackups = $remoteBackup->listRemoteBackups();
    if (not exists $allBackups->{$commonName}) {
        fatal(__x(
              'No automatic configuration backups were done for the server {s}',
                  s => $commonName,
                )
             );
    }

    my $backups = $allBackups->{$commonName};

    my $chosen;
    while (my ($name, $attrs) = each %{ $backups }) {
        if ($attrs->{Date} eq $date) {
            $chosen = $name;
            last;
        }
    }

    unless (defined $chosen) {
        fatal(__x('No configuration backups were made for the date {d} in {s} server',
              s => $commonName, d => $date));
    }

    my $tmpFile = $remoteBackup->downloadRemoteBackup($commonName, $chosen);
    EBox::Sudo::command("mv -f '$tmpFile' '$dstFile'");
    return $dstFile;
}

sub clearTmpDir
{
    my $tmpDir = tmpDir();

    EBox::Sudo::silentRoot("rm -rf $tmpDir");
}

sub createTmpDir
{
    my $tmpDir = tmpDir();
    unless ( -d $tmpDir ) {
        mkdir($tmpDir);
    }
}


sub _checkServerCN
{
    my ($serverCN, $servers, $force_r) = @_;

    if ($force_r->{noCloudLogin}) {
        return;
    }

    my $serverFound = grep { $_->{name} eq $serverCN } @{ $servers };

    unless ($serverFound) {
        fatal(__x('The server {server} is not registered in Zentyal Cloud',
                  server => $serverCN));
    }
}


sub _getDomainsInBackup
{
    my ($ebackup, $credentials, $date) = @_;

    my $listPath = _fileFromBackup($ebackup->enabledDomainsListPath());
    if (not -f $listPath) {
        EBox::warn('No backup domain lists, assuming all were backed-up');
        return undef;
    }

    my @domains = split ',', File::Slurp::read_file($listPath);

    my $domainsHash = { map { $_ => 1 } @domains };

    return $domainsHash;
}

sub _backupDomainsAvailableByPrintableName
{
    my ($metadata) = @_;

    my %domains;
    while(my ($key, $data) = each %{$metadata->{backupDomains}}) {
        # ignore failed backups
        if ($data->{failed}) {
            next;
        }
        $domains{$data->{printableName}} = $key;
    }

    return \%domains;
}

sub terminalPrompt
{
    my ($msg, $hide) = @_;

    if ($hide) {
        ReadMode('noecho');
    }

    my $input = undef;
    while (not defined $input) {
        print  $msg;
        $input = readline(*STDIN);
        print "\n";

        chomp $input;
        $input =~ s/^\s+//;
        $input =~ s/\s+$//;

        if ($input eq '') {
            $input = undef;
            print __('Please, enter a value');
            print "\n";
        }
    }

    if ($hide) {
        ReadMode('normal');
    }

    return $input;
}


sub terminalQuestion
{
    my ($msg) = @_;
    $msg .= '(y/n):';
    my $answer;
    while (not $answer) {
        $answer = terminalPrompt($msg);
        if (($answer eq 'yes') or ($answer eq 'y')) {
            return 1;
        } elsif (($answer eq 'no') or $answer eq 'n') {
            return 0;
        } else {
            print __('Please answer yes or no') , "\n";
            $answer = undef;
        }
    }
}

sub _terminalProgressIndicator
{
    my ($progressIndicator, $msg) = @_;
    my $percent = 0;
    print "\n";
    while ($percent < 100) {
        print "\r$msg: $percent%";
        $percent = $progressIndicator->percentage();
        sleep 1;
    }
    print "\r$msg: $percent%\n";

    return $progressIndicator->retValue();
}


sub _terminalDateInput
{
    my ($commonName, $dates) = @_;

    print __x('Backup dates for server {cn}', cn => $commonName);
    print "\n------------------------------------------\n";
    foreach my $date (@{ $dates }) {
        print "$date\n";
    }

    my %validDates= map { $_ => 1 } @{ $dates };

    my $selected = undef;
    while (not defined $selected) {
        print "\n";
        $selected = terminalPrompt(__('Enter backup date to restore:'));

        unless (exists $validDates{$selected}) {
             print __x('Invalid date: {d}. Try again', d => $selected);
             print "\n";
             $selected = undef;
         }
    }

    return $selected;
}

sub _zenityQuote
{
    my ($text) = @_;

    $text = shell_quote($text);

    if ($text =~ m/a href/) {
        # GTK needs these changes in URLs
        # escape ampersand
        $text =~ s/&/&amp;/g;
        # remove target attr
        $text =~ s/target=".*?"//g;
    }

    return $text;
}

sub _zenityCommonArgs
{
    my ($width) = @_;
    defined ($width) or $width = 300;

    if ( wantarray ) {
        my @args = "--width=$width";
        push(@args, '--title=' . _zenityTitle(1));
        push(@args, _zenityIcon());
        return @args;
    } else {
        my $args = "--width=$width --title " . _zenityTitle() . ' ';
        $args .= _zenityIcon() . ' ';
        return $args;
    }
}

sub _zenityTitle
{
    my ($notQuote) = @_;
    if ( $notQuote ) {
        return 'Zentyal Disaster Recovery';
    } else {
        return _zenityQuote('Zentyal Disaster Recovery');
    }
}

sub _zenityIcon
{
    my $path = EBox::Config::www() . 'favicon.ico';
    if (-r $path) {
        return "--window-icon=$path";
    }

    return '';
}

# Type: info | warning | error
#
sub _zenityMessage
{
    my ($type, $text) = @_;

    my $commonArgs = _zenityCommonArgs();
    $text = _zenityQuote($text);
    my $cmd = qq{zenity --$type $commonArgs --text=$text};

    EBox::Sudo::command($cmd);
}

sub _zenityEntry
{
    my ($text, $hide) = @_;

    $text = _zenityQuote($text);
    my $commonArgs = _zenityCommonArgs();
    my $cmd = qq{zenity --entry $commonArgs --text=$text};
    if ($hide) {
        $cmd .= ' --hide-text';
    }

    my $answer = undef;
    while (not defined $answer) {
        try {
            my $output = EBox::Sudo::command($cmd);
            $answer = _zenityAnswerFromOutput($output);
            if ($answer eq '') {
                $answer = undef;
            }
        } catch EBox::Exceptions::Command with {
            my $ex = shift;
            if ($ex->exitValue() == 1) {
                # cancel button pressed
                _zenityUserAbort();
            } else {
                $ex->throw();
            }
        };

        unless (defined $answer) {
            _zenityMessage('warning', __('This entry is mandatory to continue the restoring process. Retry'));
        }
    }

    return $answer;
}

sub _zenityQuestion
{
    my ($text) = @_;

    $text = _zenityQuote($text);
    my $commonArgs = _zenityCommonArgs();
    my $cmd = qq{zenity --question $commonArgs --text=$text};

    my $ret;
    try {
        EBox::Sudo::command($cmd);
        $ret = 1;
    } catch EBox::Exceptions::Command with {
        my $ex = shift;
        if ($ex->exitValue() == 1) {
            # exit code signals 'no' answer
            $ret = 0;
        } else {
            # exit code signals error in application
            $ex->throw();
        }
    };

    return $ret;
}

sub _zenityList
{
    my ($text, $column, $multiple, $list, %params) = @_;
    $text = _zenityQuote($text);
    my $enabledByDefault = $params{enabledByDefault};

    my $commonArgs = _zenityCommonArgs();

    my $cmd = qq{zenity --height 250 --list $commonArgs --text=$text };
    if ($multiple) {
        $cmd .=  "--checklist";
    } else {
        $cmd .= " --radiolist";
    }

    $cmd .=  q{ --column } . __('Selection') . qq{ --column "$column" };

    foreach my $element (@{ $list}) {
        my $enabled = $enabledByDefault;

        my $item;
        if (ref $element eq 'HASH') {
            $item = $element->{item};
            $enabled = $element->{enabled};
        } else {
            $item = $element;
        }

        if ($enabled) {
            $cmd .= qq{ TRUE "$item"};
        } else {
            $cmd .= qq{ FALSE "$item"};
        }
    }

    my $answer = undef;
    while (not defined $answer) {
        try {
            my $output = EBox::Sudo::command($cmd);
            $answer = _zenityAnswerFromOutput($output);
            if ($answer eq '') {
                $answer = undef;
            }
        } catch EBox::Exceptions::Command with {
            my $ex = shift;
            if ($ex->exitValue() == 1) {
                # cancel button pressed
                _zenityUserAbort();
            } else {
                $ex->throw();
            }
        };

        if (not defined $answer) {
            _zenityMessage('warning', __('This entry is mandatory to carry on the restoring process. Choose from the list'));
        }
    }

    if ($multiple) {
        my @answerList = split '\|', $answer;
        return \@answerList;
    }

    return $answer;
}


sub _zenityAnswerFromOutput
{
    my ($output) = @_;
    my $answer = $output->[0];
    defined $answer or
        return undef;

    chomp $answer;

    $answer =~ s/^\s*//;
    $answer =~ s/\s*$//;
    # Decoding UTF8 strings if any...
    utf8::decode($answer);
    return $answer;
}

sub _zenityProgress
{
    my ($text, $pulsate) = @_;

    my @commonArgs = _zenityCommonArgs($pulsate ? 300 : 400);

    my @args = ('--auto-close');
    if ($pulsate) {
        push(@args, '--pulsate');
    } else {
        push(@args, '--auto-kill');
    }

    my @cmd = ('zenity', '--progress');
    push(@cmd, @commonArgs);
    push(@cmd, @args);
    push(@cmd, "--text=$text");
    return \@cmd;
}

sub _zenityProgressIndicator
{
    my ($progressIndicator, $text) = @_;
    my $cmd = _zenityProgress($text);

    local $SIG{PIPE} = 'IGNORE';
    my $PR;
    my $pid = open ($PR, '|-');
    select ((select ($PR), $|=1)[0]); #autoflush
    if ( $pid == 0 ) {
        # Child code
        exec { $cmd->[0] } @{$cmd};
        exit(2);
    }
    my $percent = 0;
    while (not $progressIndicator->finished()) {
        $percent = $progressIndicator->percentage();
        if ($percent) {
            # Avoid progress bar premature finish:
            $percent = 99 if ($percent >= 100);

            print $PR "$percent\n" or
                _zenityProgressFail($!, $?);
        }
        my $message = $progressIndicator->message();
        if ($message) {
            # Avoid long lines that make the dialog ugly
            if ($message =~ /Downloading /) {
                my @tokens = split (' ', $message);
                $message = "$tokens[0] $tokens[3] ($tokens[4])\n";
            } elsif ($message =~ /Unpacking /) {
                $message =~ s/\(from .*\)\s//;
            }
            $message =~ s/^\s//;

            print $PR "#$text" . '\n' . "$message\n" or
                _zenityProgressFail($!, $?);
        }
        sleep 1;
    }

    close $PR or
        _zenityProgressFail($!, $?);

    if ($pid) {
        waitpid($pid, 0);
    }

    return $progressIndicator->retValue();
}

sub _zenityProgressFail
{
    my ($err, $exitValue) = @_;
    if ($err eq 'Broken pipe' and ($exitValue == 0)) {
        _zenityUserAbort();
    } elsif ($err eq 'Broken pipe') {
        # error closing progress bar. We ignore it
        return;
    } else {
        fatal("$err. Exit code: $exitValue");
    }
}


sub _showUnanticipatedProgress
{
    my ($msg) = @_;
    if ($usesX) {
        return _zenityPulsate($msg);
    } else {
        print $msg . "\n";
        print __('Please wait') . "\n";;
        return undef;
    }
}

sub _finishUnanticipatedProgress
{
    my ($pulsatePid) = @_;

    if ($usesX) {
        if (defined $pulsatePid) {
            _zenityPulsateClose($pulsatePid);
        }
    } else {
        print __('Finished') . "\n";
    }
}


sub _zenityPulsate
{
    my ($text) = @_;

    my $pid = fork();
    if ($pid) {
        # parent
        return $pid;
    }

    # child code
    chdir '/'               or die "Can't chdir to /: $!";
    open STDIN, '/dev/null' or die "Can't read /dev/null: $!";
    open STDOUT, '>/dev/null';

    die "Can't start a new session: $!" if setsid == -1;
    open STDERR, '>&STDOUT' or die "Can't dup stdout: $!";

    my $zenityCmd = _zenityProgress($text, 1);
    $pid = open my $PROC, "|-";
    if ( $pid == 0 ) {
        # Child code
        exec { $zenityCmd->[0] } @{$zenityCmd};
        exit(2);
    }

    while (1) {
        print $PROC 1;
    }
    close $PROC;

    if ($pid) {
        waitpid($pid, 0);
    }

    exit(0);
}


sub _zenityPulsateClose
{
    my ($pulsatePid) = @_;
    # Send SIGABRT
    kill(6, $pulsatePid);

    # XXX use kill -9 if it does not close

    # To avoid zombie processes, this is a blocking operation
    if ($pulsatePid) {
        waitpid($pulsatePid, 0);
    }
}

sub _zenityUserAbort
{
    my $msg = __('Restoring process aborted upon user request');
    fatal($msg);
}


sub _remoteUrlParamsFromCredentials
{
    my ($credentials, $targetType) = @_;

    my $target = $credentials->{server} . '/' . $credentials->{commonName} ;
    $target .= "/$targetType";
    my %params = (
        method => $credentials->{method},
        user   => $credentials->{username},
        password => $credentials->{password},
        target => $target,
        encValue => $credentials->{encValue},
        encSelected => $credentials->{encSelected},
        alternativePassword => 1,
        credentials => $credentials,
    );

    return \%params;
}

# Perform saving changes
sub saveChanges
{
    my ($msg, $retry) = @_;
    defined($msg) or $msg =  __('Saving configuration changes');
    defined($retry) or $retry = 1;

    my $global = EBox::Global->getInstance();
    if (not $global->unsaved()) {
        return;
    }

    my $progressIndicator = $global->prepareSaveAllModules();

    my $retValue = progress($progressIndicator, $msg);
    if ($retValue != 0) {
        my $errorMsg = $progressIndicator->errorMsg();
        if ($retry) {
            # first try, save changes failed, do a retry
            $errorMsg or $errorMsg = 'Unknown';
            EBox::warn("Error saving changes (will retry): $errorMsg");
            saveChanges($msg, 0);
        } else {
            if ($errorMsg) {
                my $msg = $errorMsg . "\n";
                $msg .= __('Error saving configuration changes; some Zentyal modules would remain in a unknown state');
                error($msg);
                return;
            } else {
                EBox::warn("Progress indicator for saveChanges does not specify any error but has returned the following value: $retValue.");
            }
        }
    }
}

# Regenerate the ebackup cache for file list that it is not done
# already for restarting the module so we have to do it by hand
sub regenerateCaches
{
    my $msg = __('Regenerating file list cache');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    try {
        my $ebackup = EBox::Global->modInstance('ebackup');
        $ebackup->remoteGenerateListFile();
    }  catch EBox::Exceptions::NotConnected with {
        warning(
                __('Cannot connect to the Cloud to regenerate backup list. Please try again later.'),
                noBlocking => 1
               );
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub _xauthCookie
{
    unless ($usesX) {
        return undef;
    }

    my $cmd = 'xauth list';
    my @output = `$cmd`;
    foreach my $line (@output) {
        chomp $line;
    }
    return \@output;
}

sub _xauthEBox
{
    my ($cookieList) = @_;

    unless($usesX) {
        return;
    }

    my $xauthFile = '/var/lib/zentyal/.Xauthority';
    EBox::Sudo::root("rm -f $xauthFile");
    EBox::Sudo::root("touch $xauthFile");
    EBox::Sudo::root("chown ebox.ebox $xauthFile");

    foreach my $cookie (@{ $cookieList }) {
        EBox::Sudo::command("xauth -f $xauthFile add $cookie");
    }
}

sub progress
{
    my ($progressIndicator, $msg)  = @_;

    if (not $progressIndicator->started()) {
        $progressIndicator->runExecutable();
    }

    if ($usesX) {
        return _zenityProgressIndicator($progressIndicator, $msg);
    } else {
        return _terminalProgressIndicator($progressIndicator, $msg);
    }
}

sub getUserAndPasswordAndServers
{
    my ($user, $password, $force_r) = @_;

    if ($force_r->{noCloudLogin}) {
        return {
            user     => undef,
            password => undef,
            servers  => [],
        };
    }

    my $remoteServices = EBox::Global->modInstance('remoteservices');
    my $servers;

    while (not ($user and $password)) {
        if (not $user) {
            $user = input(__('Zentyal Cloud User'));
        }
        if (not $password) {
            $password = password(__('Zentyal Cloud Password'));
        }

        try {
            $servers = serverList($remoteServices, $user, $password);
        } catch EBox::Exceptions::External with {
            my $ex = shift;
            error("$ex");
            $user = $password = '';
        };
    }

    unless (defined $servers and @{$servers}) {
        $servers = serverList($remoteServices, $user, $password);
        unless ( defined $servers and @{$servers} ) {
            fatal(__x("The account {user} do not have any registered Zentyal servers",
                      user => $user));
        }
    }

    return {
        user => $user,
        password => $password,
        servers => $servers,
    };
}

sub getCredentials
{
    my ($user, $password, $servers, $serverCN, $force_r) = @_;

    if ($serverCN) {
        _checkServerCN($serverCN, $servers, $force_r);
    } else {
        $serverCN = askServerCN($servers);
    }

    my $remoteServices = EBox::Global->modInstance('remoteservices');
    my $credentials = backupCredentials(
                                        remoteServices => $remoteServices,
                                        username       => $user,
                                        password       => $password,
                                        serverCN       => $serverCN,
                                        force          => $force_r,
                                       );

    if ($credentials->{type} eq 'basic') {
        my $infoMsg = __('If you had enabled the Disaster Recovery service in Small Business or Enterprise Edition, besides the configuration you are about to recover, you could have restored the data of the active modules.');
        info($infoMsg);
    }

    _setupPasswords($credentials);
    return $credentials;
}

sub getEncryption
{
    my ($credentials, $metadata, %params) = @_;

    if ($credentials->{type} eq 'basic') {
        return;
    }

    my $noEncryption      = $params{noEncryption};
    my $symmetricPassword = $params{symmetricPassword};
    my $encryptionKey     = $params{encryptionKey};
    my $keyPassphrase     = $params{keyPassphrase};

    if ((not $noEncryption) and
        (not defined $symmetricPassword) and
        (not defined $encryptionKey) )  {

        if (_backupUsesEncryption($credentials, $metadata)) {
            my $dialogMsg =  __x(
                  'Enter password used to encrypt back up {ser}',
                   ser => $credentials->{commonName});
            $symmetricPassword = password($dialogMsg); # 
        }
    }

    $credentials = addEncryptionToCredentials($credentials,
                symmetricPassword => $symmetricPassword,
                encryptionKey     => $encryptionKey,
                keyPassphrase     => $keyPassphrase,
                );

    if ($symmetricPassword) {
        # udpate passwords with symmetric password
        _setupPasswords($credentials);
    }
}

sub _retrySymmKey
{
    my ($urlParams) = @_;
    my $credentials = $urlParams->{credentials};
    my $newKey;

    my $dialogMsg =  __x(
        'Incorrect password. Please, enter the correct password used for encrypt {ser}.',
        ser => $credentials->{commonName});
    $newKey = password($dialogMsg);

    $credentials = addEncryptionToCredentials($credentials,
                symmetricPassword => $newKey,
                encryptionKey     => $credentials->{encryptionKey},
                keyPassphrase     => $credentials->{keyPassphrase},
                );
    _setupPasswords($credentials);
}

sub _backupUsesEncryption
{
    my ($credentials, $metadata) = @_;
    if ($metadata) {
        my $encType = $metadata->{encryptionType};
        return ($encType eq 'symmetric');
    }

    return EBox::EBackup::Subscribed::collectionEncrypted($credentials);
}

sub readMetadataFile
{
    my ($path) = @_;
    my ($yaml) = YAML::XS::LoadFile($path);

    return $yaml->{backup};
}

sub getBackupDomainsToRestore
{
    my ($credentials, $metadata, $restoreAll, $domainsCli) = @_;

    my @domainsCli = @{ $domainsCli };
    my $domains;

    if ($credentials->{type} eq 'subscribed') {
        if ($restoreAll) {
            $domains = { map { $_ => 1 } keys %{ $metadata->{backupDomains} } };
        } elsif (not @domainsCli) {
            # ask to the user
            $domains = askDomainsToRestore($credentials, $metadata);
        } else {
            $domains = { map { $_ => 1 } @domainsCli };
        }

    } else {
        @domainsCli = grep { $_ ne 'configuration' } @domainsCli;
        if (@domainsCli) {
            fatal (__x('The following backup domains could not be restored from a basic subscription: {domains}',
                       domains => "@domainsCli"));
        }
        $domains = { configuration => 1 };
    }

    return $domains;
}


sub _logStartProcess
{
    my ($credentials, $date, $toRestore) = @_;
    my $commonName = $credentials->{commonName};
    my $domains = join ', ', keys %{ $toRestore };
    my $msg = "Restore process started. Using data from $commonName at $date. Backup domains: $domains";
    EBox::info($msg);
}

sub _apachePort
{
    my $apache = EBox::Global->getInstance(1)->modInstance('apache');
    return $apache->port();
}

sub takeFilesMD5
{
    my @files = ('/etc/passwd',
                 '/etc/shadow',
                );
    foreach my $file (@files) {
        $filesMD5{$file} = _fileMD5($file);
    }
}

# doesnt discriminate between added, removed and modfied 
sub checkFilesMD5
{
    my @changed;
    while (my ($file, $oldMd5) = each %filesMD5) {
        my $newMD5 = _fileMD5($file);
        if (defined $oldMd5 and defined $newMD5) {
            if ($oldMd5 ne $newMD5) {
                # changed
                push @changed, $file;
            }
        } elsif (defined $oldMd5 and not defined $newMD5) {
            # removed
            push @changed, $file;
        } elsif (not defined $oldMd5 and defined $newMD5) {
            # added
            push @changed, $file;
        }
    }

    my %changed =    map { $_ => 1 } @changed;
    return \%changed;
}

sub _fileMD5
{
    my ($file)= @_;
    my $fileSum;
    if (EBox::Sudo::fileTest('-r', $file)) {
        my $md5Cmd= "md5sum '$file'";
        try {
            my $output  =  EBox::Sudo::root($md5Cmd);
            my $outputLine = $output->[0];
            ($fileSum) = split '\s', $outputLine; # removing file name
        } catch EBox::Exceptions::Command with {
                my ($ex) = shift @_;
                my $error = join '', @{ $ex->error() };
                EBox::error("error making m5sum of file: $file");
        };
    } else {
        EBox::error("Cannot get MD5 of file $file, because it could not be read");
    }

    return $fileSum;
}


sub setHostname
{
    my ($metadata) = @_;
    my $hostname = exists $metadata->{hostname} ?
                          $metadata->{hostname} : undef;
    if ($hostname) {
        my $cmd = CHANGE_HOSTNAME_SCRIPT . ' ' . $hostname;
        EBox::Sudo::root($cmd);
    } else {
        EBox::info("No hostname metadata found");
    }
}

sub _finishedChangedFilesWarnings
{
    my ($files) = @_;

    if ($files->{'/etc/password'}) {
        # XXX check wether  the local user is the same or not
        warning(
            __(
                'The local password file has changed, the local users and their password could have been changed. We reccomend you to logut and login again with a valid user to avoid user identity problems.'
               )
           );
    } elsif ($files->{'/etc/shadow'}) {
        warning(
     __('The shadow password file was restored; your local user password could have been changed')
           );
    }
}

sub _finishedHostnameFilesWarnings
{
    my ($changedFiles) = @_;
    if ($changedFiles->{'/etc/hostname'} or $changedFiles->{'/etc/hosts'}) {
        warning(
            __('No hostname infromation found in metadata but hostname configuration files changed; please fix your hostname manually or with the Zentyal option found at System -> General.')
           );
    }
}

sub showPendingMessages
{
    foreach my $pending (@pendingMessages) {
        my $type    = $pending->{type};
        my $params = $pending->{'params'};
        if ($type eq 'info') {
            info(@{ $params });
        } elsif ($type eq 'warning') {
            warning(@{ $params });
        } elsif ($type eq 'error') {
            error(@{ $params });
        }
    }
}

sub finishedMessages
{
    my ($credentials, $metadata) = @_;
    showPendingMessages();

    my $changedFiles = checkFilesMD5();
    if (keys %{ $changedFiles }) {
        _finishedChangedFilesWarnings($changedFiles);
        if (not $metadata->{hostname}) {
            _finishedHostnameFilesWarnings($changedFiles);
        }
    }

    # XXX add warnings of changed apache port
    # XXX add warnings of changed ebox modules?
    finalMessage($credentials);
}

# The last message to finish the restore
sub finalMessage
{
    my ($credentials) = @_;

    my $msg = '';
    if ( $credentials->{type} eq 'basic' ) {
        $msg = __s('Your configuration backup is now restored!') . "\n\n" .
               __s('Perhaps you could be interested in the Zentyal Disaster Recovery service? This service guarantees that your most business critical data will be stored in a safe remote location and can be recovered easily in case of a disaster.');
    } else {
        $msg = __('Your full backup is now successfully restored!');
    }

    my $url = 'https://localhost';
    my $port = _apachePort();
    if ($port != 443) {
        $url .= ":$port";
    }

    $msg .= "\n\n";
    $msg .= __x('You can now login at {url} to manage your recovered host.',
                 url => $url);

    info($msg);
}

sub info
{
    my ($msg, %params) = @_;
    my $noBlocking = delete $params{noBlocking};
    my $noLog      = delete $params{noLog};

    unless ($noLog) {
        EBox::info($msg);
    }

    if ($usesX) {
        if ($noBlocking) {
            print "$msg\n";
            push @pendingMessages, {
                type => 'info',
                params => [$msg, %params, noLog => 1]
               };
        } else {
            _zenityMessage('info', $msg);
        }
    } else {
        print "$msg\n";
    }
}

sub error
{
    my ($msg, %params) = @_;
    my $exception = $params{exception};
    my $noBlocking = delete $params{noBlocking};
    my $noLog      = delete $params{noLog};

    unless ($noLog) {
        if (defined $exception ) {
            EBox::error("Unexpected error: $exception");
        } else {
            EBox::error($msg);
        }
    }

    if ($usesX) {
        if ($noBlocking) {
            print STDERR "$msg\n";
            push @pendingMessages, {
                type => 'error',
                params => [$msg, %params, noLog => 1]
               };
        } else {
            _zenityMessage('error', $msg);
        }
    } else {
        print STDERR "$msg\n";
    }
}

sub warning
{
    my ($msg, %params) = @_;

    my $noBlocking = delete $params{noBlocking};
    my $noLog      = delete $params{noLog};

    unless ($noLog) {
        EBox::warn($msg);
    }

    if ($usesX) {
        if ($noBlocking) {
            print __x('Warning: {msg}', msg => "$msg\n");
            push @pendingMessages, {
                type => 'warning',
                params => [$msg, %params, noLog => 1]
               };
        } else {
            _zenityMessage('warning', $msg);
        }
    } else {
        print __x('Warning: {msg}', msg => "$msg\n");
    }
}

sub input
{
    my ($msg, $masked) = @_;

    if ($usesX) {
        return _zenityEntry($msg, $masked);
    } else {
        return terminalPrompt("$msg: ", $masked);
    }
}

sub password
{
    my ($msg) = @_;

    input($msg, 1);
}

sub showException
{
    my ($exception, $showRealMsg) = @_;

    my $msg;
    if ($showRealMsg) {
        $msg = $exception;
    } else {
        $msg = __('Sorry, an unexpected error has occurred. Please contact support and check the /var/log/zentyal/zentyal.log file for further details.');        
    }

    error($msg, exception => $exception);

    return $msg;
}

my $_fatalShow = 0;
sub fatal
{
    my ($input, $showRealMsg) = @_;

    EBox::error("Restore fatal error: $input");

    if (not $_fatalShow) {
        my $msg = showException($input, $showRealMsg);
        $_fatalShow = 1;
        die $msg;
    }

    die __('Restore process aborted');
}


# Copyright (C) 2004  Warp Netwoks S.L.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

package EBox::Squid;
use strict;
use warnings;

use base qw(EBox::GConfModule EBox::FirewallObserver EBox::ObjectsObserver);

use EBox::Objects;
use EBox::Global;
use EBox::Config;
use EBox::Firewall;
use EBox::Validate qw( :all );
use EBox::Exceptions::InvalidData;
use EBox::Exceptions::Internal;
use EBox::Exceptions::DataNotFound;
use EBox::SquidFirewall;
use EBox::SquidOnlyFirewall;
use EBox::Summary::Module;
use EBox::Summary::Value;
use EBox::Summary::Status;
use EBox::Summary::Section;
use EBox::Menu::Item;
use EBox::Menu::Folder;
use EBox::Sudo qw( :all );
use EBox::Gettext;
use EBox;
use Error qw(:try);
use HTML::Mason;


#Module local conf stuff
use constant SQUIDCONFFILE => "@SQUIDCONF@";
use constant SQUIDINIT     => "/etc/init.d/squid";
use constant DGINIT     => "/etc/init.d/dansguardian";
use constant PIDFILE       => "/var/run/squid.pid";
use constant DGPIDFILE	=> "/var/run/dansguardian.pid";
use constant MAXDOMAINSIZ 		=> 255; 
use constant SQUIDPORT => '3128';
use constant DGPORT => '3129';
use constant DGDIR => '/etc/dansguardian';


sub _create 
{
	my $class = shift;
	my $self  = $class->SUPER::_create(name => 'squid', 
					   domain => 'ebox-squid',
					   @_);
	$self->{logger} = EBox::logger();
	bless ($self, $class);
	return $self;
}

sub isRunning
{
	my $self = shift;
	return $self->pidFileRunning(PIDFILE);
}

sub DGIsRunning
{
	my $self = shift;
	return $self->pidFileRunning(DGPIDFILE);
}

sub _doDaemon
{
	my $self = shift;
	my $action = undef;

	if ($self->service and $self->isRunning) {
		$action = 'reload';
	} elsif ($self->service) {
		$action = 'start';
	} elsif ($self->isRunning) {
		$action = 'stop';
	} else {
		return;
	}

	my $command =  SQUIDINIT . " " . $action . " 2>&1";
	root($command);
}

sub _doDGDaemon
{
	my $self = shift;
	my $action = undef;

	if ($self->_dgNeeded and $self->DGIsRunning) {
		$action = 'restart';
	} elsif ($self->_dgNeeded) {
		$action = 'start';
	} elsif ($self->DGIsRunning) {
		$action = 'stop';
	} else {
		return;
	}

	my $dgcommand =  DGINIT . " " . $action . " 2>&1";
	root($dgcommand);
}
sub _stopService 
{
	my $self = shift;
	if ($self->isRunning) {
		root(SQUIDINIT . " stop 2>&1");
	}
	if ($self->DGIsRunning) {
		root(DGINIT . " stop 2>&1");
	}
	
}

# Method: _regenConfig
#
#       Overrides base method. It regenertates the configuration
#       for squid and dansguardian.
#
sub _regenConfig 
{
	my $self = shift;
	$self->_setSquidConf;
	$self->_doDaemon();
	$self->_doDGDaemon();
}

#
# Method: usesObject
#       
#       Implements EBox::ObjectsObserver interface
#
sub usesObject # (object)
{
	my ($self, $object) = @_;
	if ($self->isUnfiltered($object) or $self->isBan($object)) {
		return 1;
	}
	return undef;
}

#
# Method: freeObject
#       
#       Implements EBox::ObjectsObserver interface
#
sub freeObject # (object) 
{
	my ($self, $object) = @_;
	(defined($object) && $object ne "") or return;

	my @unfiltered = @{$self->unfiltered};
	my @bans = @{$self->bans};

	if (grep(/^$object$/, @unfiltered)) {
		my @array = ();
		foreach (@unfiltered) {
			($_ ne $object) or next;
			push(@array, $_)
		}
		$self->setUnfiltered(\@array);
	}

	if (grep(/^$object$/, @bans)) {
		my @array = ();
		foreach (@bans) {
			($_ ne $object) or next;
			push(@array, $_)
		}
		$self->setBans(\@array);
	}
}

#
# Method: setUnfiltered
#
#	Sets a list of objects as unfiltered. This means these objects
#	will not pass through any filter, neither dansguardian nor banned sites
#
# Parameters:
#
#	array ref - holding the object names
#
sub setUnfiltered # (\@objects)
{
	my ($self, $args) = @_;
	my $objects = EBox::Global->modInstance('objects');
	$self->unset("unfiltered");
	($args) or return;
	my @bans = @{$self->bans};
	my $bansflag = undef;
	foreach my $obj (@{$args}) {	
		$objects->objectExists($obj) or
			throw EBox::Exceptions::DataNotFound(
				'data' => __("object"), 'value' => $obj);
		if (grep(/^$obj$/, @bans)) {
			@bans = grep(!/^$obj$/, @bans);
			$bansflag = 1;
		}
        }
	$self->set_list("unfiltered", "string", $args);
	$bansflag and $self->setBans(\@bans);
}

#
# Method: filtered
#
#	Returns a list of filtered objects
#
# Parameters:
#
#	array ref - holding the object names
#
sub filtered
{
	my $self = shift;
	my $objects = EBox::Global->modInstance('objects');
	my @no = @{$self->unfiltered};
	push(@no, @{$self->bans});
	my @names = @{$objects->ObjectNames};
	my @filtered = ();
	foreach my $n (@names) {
		unless (grep(/^$n$/, @no)) {
			push(@filtered, $n);
		}
	}
	return \@filtered;
}

# Method: unfiltered
#
#	Returns a list of unfiltered objects
#
# Parameters:
#
#	array ref - holding the object names
#
sub unfiltered
{
	my $self = shift;
	return $self->get_list("unfiltered");
}

# Method: isUnfiltered
#
#	Checks if a given object is set as unfiltered
#
# Parameters:
#
#	object - object name
#
# Returns:
#
#	boolean - true if it's set as unfiltered, otherwise false
sub isUnfiltered # ($object)
{
	my ($self, $object) = @_;
	my $unfiltered = $self->unfiltered();
	foreach (@{$unfiltered}) {
		return 1 if ($_ eq $object);
	}
	return undef;
}

#
# Method: setBans
#
#	Sets the list of banned objects. This objects could not be browse.
# 
# Parameters:
#
#	array ref - holding the objects
#
sub setBans # (\@bans)
{
	my ($self, $args) = @_;
	my $objects = EBox::Global->modInstance('objects');
	$self->unset("bans");
	($args) or return;
	my @unfiltered = @{$self->unfiltered};
	my $unfilteredflag = undef;
	foreach my $obj (@{$args}) {	
		$objects->objectExists($obj) or
			throw EBox::Exceptions::DataNotFound(
				'data' => __("object"), 'value' => $obj);
		if (grep(/^$obj$/, @unfiltered)) {
			@unfiltered = grep(!/^$obj$/, @unfiltered);
			$unfilteredflag = 1;
		}
        }
	$self->set_list("bans", "string", $args);
	$unfilteredflag and $self->setUnfiltered(\@unfiltered);
}

#
# Method: bans
#
#	Returns the list of banned objects.
# 
# Returns:
#
#	array ref - holding the objects
#
sub bans
{
	my $self = shift;
	return $self->get_list("bans");
}

# Method: isBan
#
#	Checks if a given object is banned
#
# Parameters:
#
#	object - object name
#
# Returns:
#
#	boolean - true if it's set as banned, otherwise false
sub isBan # ($object)
{
	my ($self, $object) = @_;
	my $bans = $self->bans();
	foreach (@{$bans}) {
		return 1 if ($_ eq $object);
	}
	return undef;
}

#sets authentication 
#Par: 0 -> boolean
sub setAuth # (auth)
{
	my ($self, $auth) = @_;
	($auth and $self->auth) and return;
	(!$auth and !$self->auth) and return;
	$self->set_bool('auth', $auth);
}

#returns authentication 
#ret: boolean
sub auth
{
	my $self = shift;
	return $self->get_bool('auth');
}

# Method: setService 
#
#       Enable/Disable the proxy service 
#
# Parameters:
#
#       enabled - boolean. True enable, undef disable
#
sub setService # (enabled) 
{
	my ($self, $active) = @_;
	($active and $self->service) and return;
	(!$active and !$self->service) and return;
	$self->set_bool('active', $active);
}

# Method: service 
#
#       Returns if the proxy service is enabled  
#
# Returns:
#
#       boolean - true if enabled, otherwise undef   
sub service
{
	my $self = shift;    	
	return $self->get_bool('active');
}

# Method: setTransproxy
#
#      Sets the transparent proxy mode. 
#
# Parameters:
#
#       enabled - boolean. True enable, undef disable
#
sub setTransproxy # (enabled)
{
	my ($self, $trans) = @_;
	($trans and $self->transproxy) and return undef;
	(!$trans and !$self->transproxy) and return undef;
	$self->set_bool('transproxy', $trans);
	return 1;
}

# Method: transproxy 
#
#       Returns if the transparent proxy mode is enabled  
#
# Returns:
#
#       boolean - true if enabled, otherwise undef   
#
sub transproxy
{
	my $self = shift;    	
	return $self->get_bool('transproxy');
}

# Method: setPort
#
#       Sets the listening port for the proxy
#
# Parameters:
#
#       port - string: port number
#
sub setPort # (port)
{
	my ($self, $port) = @_;
	my $fw = EBox::Global->modInstance('firewall');
	checkPort($port, "listening port");
	my $currentport = $self->port();	
	if ($currentport == $port) {
		return;
	}
	unless ($fw->availablePort($port)) {
		throw EBox::Exceptions::DataExists(
					'data'  => __('listening port'),
					'value' => $port);
	}					
	if ($port eq $self->port) {
		return undef;
	}
	$self->set_int("port", $port);
	return 1;
}


# Method: port
#
#       Returns the listening port for the proxy
#
# Returns:
#
#       string - port number
#
sub port
{
	my $self = shift;    	
	return $self->get_int("port");
}

# Method: bannedDomains 
#
#	Returns the list of banned domains.
# 
# Returns::
#
#	array ref - holding the domains
#
sub bannedDomains
{
	my $self = shift;
	return $self->get_list("banned_sites");
}

# Method: bannedDomainExists
#
#	Checks if a banned domain already exists
# 
# Returns:
#
#       boolean - true if exists, otherwise false
#
sub bannedDomainExists # (domain)
{
	my $self = shift;
	my $domain = shift;

	foreach (@{$self->bannedDomains()}) {
		return 1 if ($_ eq $domain);
	}
	return undef;
}

# Method: allowedDomains 
#
#	Returns the list of allowed domains.
# 
# Returns:
#
#	array ref - holding the domains
#
sub allowedDomains
{
	my $self = shift;
	return $self->get_list("allowed_sites");
}

# Method: allowedDomainExists
#
#	Checks if a banned domain already exists
# 
# Returns:
#
#       boolean - true if exists, otherwise false
#
sub allowedDomainExists # (domain)
{
	my $self = shift;
	my $domain = shift;

	foreach (@{$self->allowedDomains()}) {
		return 1 if ($_ eq $domain);
	}
	return undef;
}

sub _checkDomainName # (domain)
{
	my $self = shift;
	my $domain = shift;
	
	unless (length($domain) < MAXDOMAINSIZ) {
		return undef;
	}
	unless ($domain =~ /^[^\.\-][\w\.\-]+[^\-]$/) {
		return undef;
	}
	return 1;
}

#
sub ipBlocked #
{
	my $self = shift;
	return $self->get_bool("block_ip");
}

sub setIpBlocked #
{
	my ($self, $block) = @_;
	if ($block && $self->ipBlocked) {
		return;
	} elsif (!$block && !$self->ipBlocked){
		return;
	}
	$self->set_bool("block_ip", $block);
}

# Method: globalPolicy
#
#	Returns the global policy
# 
# Returns:
#
#       string - allow | deny | filter
#
sub globalPolicy #
{
	my $self = shift;
	return $self->get_string("policy");
}

# Method: setGlobalPolicy
#
#	Sets the global policy. This is the policy that will be used for those
#	objects without an own policy.
# 
# Parameters:
#
#       policy  - allow | deny | filter
#
sub setGlobalPolicy # (policy)
{
	my ($self, $policy) = @_;
	if ($policy ne 'allow' && $policy ne 'deny' && $policy ne 'filter') {
		throw EBox::Exceptions::Internal(
                        __x("Policy '{policy}' is invalid", policy => $policy));
	}
	if ($policy eq $self->globalPolicy) {
		return undef;
	}
	$self->set_string("policy", $policy);
	return 1;
}

# Method: addBannedDomain 
#
#	Add a new banned domain.
# 
# Parameters:
#
#       domain - string: domain to ban
#
sub addBannedDomain # (domain)
{
	my $self = shift;
	my $domain = shift;

	unless ($self->_checkDomainName($domain)) {
  		throw EBox::Exceptions::InvalidData(
				'data' => __('domain name'),
	  			'value' => $domain); 
	}
	if ($self->bannedDomainExists($domain)) {
                 throw EBox::Exceptions::DataExists(
		 		'data' => __('domain name'),
                                'value' => "$domain");
	}
	my @list = @{$self->bannedDomains()};
	push @list, $domain;
	$self->set_list("banned_sites", "string", \@list);	
	return 1;
}

# Method: removeBannedDomain 
#
#	Removes a banned domain.
# 
# Parameters:
#
#       domain - string: domain to remove
#
sub removeBannedDomain # (domain)
{
	my ($self, $domain) = @_;

	unless ($self->bannedDomainExists($domain)) {
		 throw EBox::Exceptions::DataNotFound(
		 		'data' => __("domain"), 
				'value' => $domain); 
	}
	
	my @list = @{$self->bannedDomains()};
	@list = grep (!/^$domain$/, @list);
	$self->set_list("banned_sites", "string", \@list);	
	return 1;
}

# Method: addAllowedDomain 
#
#	Add a new allowed domain.
# 
# Parameters:
#
#       domain - string: domain to allow
#
sub addAllowedDomain # (domain)
{
	my $self = shift;
	my $domain = shift;

	unless ($self->_checkDomainName($domain)) {
  		throw EBox::Exceptions::InvalidData(
				'data' => __('domain name'),
	  			'value' => $domain); 
	}
	if ($self->allowedDomainExists($domain)) {
                 throw EBox::Exceptions::DataExists(
		 		'data' => __('domain name'),
                                'value' => "$domain");
	}
	my @list = @{$self->allowedDomains()};
	push @list, $domain;
	$self->set_list("allowed_sites", "string", \@list);	
	return 1;
}

# Method: removeAllowedDomain 
#
#	Removes an allowed domain.
# 
# Parameters:
#
#       domain - string: domain to remove
#
sub removeAllowedDomain # (domain)
{
	my ($self, $domain) = @_;

	unless ($self->allowedDomainExists($domain)) {
		 throw EBox::Exceptions::DataNotFound(
		 		'data' => __("domain"), 
				'value' => $domain); 
	}
	
	my @list = @{$self->allowedDomains()};
	@list = grep (!/^$domain$/, @list);
	$self->set_list("allowed_sites", "string", \@list);	
	return 1;
}

# Function: setBanThreshold
#
# 	Sets the weighted phrase value that will cause a page to be banned by 
# 	the  content-based filter.
#
# Parameters:
#
# 	threshold - A positive integer with the desired threshold. A value of 0
# 		    will disable the content filter. Acording to dansguardian
# 		    documentation, recommended values are:
#	 		* 50 for young children
#	 		* 100 for old children
#	 		* 160 for young adults
sub setBanThreshold # (threshold)
{
	my ($self, $thres) = @_;
	unless ($thres =~ /^\d+$/) {
		throw EBox::Exceptions::InvalidData(data=>__('Threshold'),
						value=>$thres);
	}
	my $old_thres = $self->banThreshold;
	($thres ne $old_thres) or return;
	$self->set_int('threshold', $thres);
}

# Function: banThreshold
#
# 	Gets the weighted phrase value that will cause a page to be banned.
#
# Returns:
#
# 	A positive integer with the current ban threshold.
sub banThreshold
{
	my $self = shift;
	return $self->get_int('threshold');
}

sub _dgNeeded
{
	my $self = shift;
	$self->service or return undef;
	$self->ipBlocked and return 1;
	($self->banThreshold > 0) and return 1;
	(scalar(@{$self->bannedDomains}) > 0) and return 1;
	(scalar(@{$self->allowedDomains}) > 0) and return 1;
	return undef;
}

#
# Function: usesPort
#
#	Implements EBox::FirewallObserver interface
#
sub usesPort # (protocol, port, iface)
{
	my ($self, $protocol, $port, $iface) = @_;
	($protocol eq 'tcp') or return undef;
	# DGPORT is hard-coded, it is reported as used even if
	# the service is disabled.
	($port eq DGPORT) and return 1;
	# the port selected by the user (by default SQUIDPORT) is only reported
	# if the service is enabled
	($self->service) or return undef;
	($port eq $self->port) and return 1;
	return undef;
}

sub _setSquidConf
{
	my $self = shift;
	if ($self->_dgNeeded) {
		$self->_squidAndDG;
	} else {
		$self->_squidOnly;
	}
}

sub _squidOnly
{
	my $self = shift;
	my $ob = EBox::Global->modInstance('objects');
	my $objects;
	my $policy = $self->globalPolicy;
	my $squidpolicy = $policy;
	my $trans = 'no';
	my @exceptions = ();
	($self->transproxy) and $trans = 'yes';

	if ($policy eq 'deny') {
		push(@exceptions, @{$self->filtered});
		push(@exceptions, @{$self->unfiltered});
	} else {
		$squidpolicy = "allow";
		push(@exceptions, @{$self->bans});
	}
	
	foreach my $aux (@exceptions) {
		foreach my $addr (@{$ob->ObjectAddresses($aux)}) {
			$objects .= "acl objects src  $addr\n";
		}
	}

	my @array = ();
	push(@array, 'port'  => $self->port);
	push(@array, 'transparent'  => $trans);
	push(@array, 'policy'  => $squidpolicy);
	push(@array, 'objects' => $objects);

	$self->writeConfFile(SQUIDCONFFILE, "squid/squid.conf.mas", \@array);
}

# Function: dansguardianPort 
#
# 	Returns the listening port for dansguardian
#
# Returns:
#
#	string - listening port
sub dansguardianPort
{
	return DGPORT;
}

sub _squidAndDG
{
	my $self = shift;
	my $ob = EBox::Global->modInstance('objects');
	my $objects;
	my $banned = $self->bannedDomains;
	my $allowed = $self->allowedDomains;
	my $policy = $self->globalPolicy;
	my $squidpolicy = $policy;
	my $trans = 'no';
	my $block_ip = 'no';
	my @exceptions = ();
	my $threshold = $self->banThreshold;
	($self->transproxy) and $trans = 'yes';
	($self->ipBlocked) and $block_ip = 'yes';

	if ($policy eq 'allow') {
		push(@exceptions, @{$self->bans});
		push(@exceptions, @{$self->filtered});
	} else {
		$squidpolicy = "deny";
		push(@exceptions, @{$self->unfiltered});
	}
	
	foreach my $aux (@exceptions) {
		foreach my $addr (@{$ob->ObjectAddresses($aux)}) {
			$objects .= "acl objects src  $addr\n";
		}
	}

	my @array = ();
	push(@array, 'port'  => $self->port);
	push(@array, 'transparent'  => $trans);
	push(@array, 'policy'  => $squidpolicy);
	push(@array, 'objects' => $objects);

	$self->writeConfFile(SQUIDCONFFILE, "squid/squid.conf.mas", \@array);

	my $locale = EBox::locale();
	my $lang = 'ukenglish';
	if ($locale =~ /^es_/) {
		$lang = 'arspanish';
	} elsif ($locale =~ /^fr_/) {
		$lang = 'french';
	}

	@array = ();
	# FIXME - get a proper lang name for the current locale
	push(@array, 'port'  => DGPORT);
	push(@array, 'lang'  => $lang);
	push(@array, 'squidport'  => $self->port);
	$self->writeConfFile(DGDIR . "/dansguardian.conf", 
				"squid/dansguardian.conf.mas", \@array);

	@array = ();
	push(@array, 'threshold'  => $threshold);
	$self->writeConfFile(DGDIR . "/dansguardianf1.conf", 
				"squid/dansguardianf1.conf.mas", \@array);

	@array = ();
	push(@array, 'block_ip'  => $block_ip);
	push(@array, 'domains'  => $banned);
	$self->writeConfFile(DGDIR . "/bannedsitelist", 
				"squid/bannedsitelist.mas", \@array);

	@array = ();
	push(@array, 'domains'  => $allowed);
	$self->writeConfFile(DGDIR . "/exceptionsitelist", 
				"squid/exceptionsitelist.mas", \@array);
}

sub firewallHelper 
{
	my $self = shift;
	if ($self->service) {
		if ($self->_dgNeeded()) {
			return new EBox::SquidFirewall();
		} else  {
			return new EBox::SquidOnlyFirewall();
		}
	}
	return undef;
}

#manage squid via init.d/squid script
#Pars 0: start|stop|restart
sub _daemon # (action)
{
	my ($self, $action) = @_;
	my $command =  SQUIDINIT . " " . $action . " 2>&1";

	if ( $action eq 'start') {
		root($command);
	} elsif ( $action eq 'stop') {
		root($command);
	} elsif ( $action eq 'reload') {
		root($command);
	} else {
		throw EBox::Exceptions::Internal("Bad argument: $action");
	}
	
}

sub statusSummary
{
	my $self = shift;
	return new EBox::Summary::Status('squid', __('HTTP Proxy'),
					$self->isRunning, $self->service);
}

# Method: menu 
#
#       Overrides EBox::Module method.
#   
#     
sub summary
{
	my $self = shift;
	$self->isRunning() or return undef;

	my $item = new EBox::Summary::Module(__("Proxy"));
	my $section = new EBox::Summary::Section();
	my $status;
	$item->add($section);
	
	if ($self->transproxy) {
		$status = __("Enabled");
	} else {
		$status = __("Disabled");
	}
	$section->add(new EBox::Summary::Value(__("Transparent proxy"),$status));
	
	if ($self->globalPolicy eq 'allow') {
		$status = __("Allow");
	} elsif ($self->globalPolicy eq 'deny') {
		$status = __("Deny");
	} elsif ($self->globalPolicy eq 'filter') {
		$status = __("Filter");
	}

	$section->add(new EBox::Summary::Value(__("Global policy"), $status));
	
	$section->add(new EBox::Summary::Value(__("Listening port"), 
					       $self->port));
	return $item;
}

# Method: rootCommands 
#
#       Overrides EBox::Module method.
#   
#     
sub rootCommands 
{
	my $self = shift;
	my @array = ();
	push(@array, SQUIDINIT);
	push(@array, DGINIT);
	push(@array,"/bin/mv ".EBox::Config::tmp ."* ".SQUIDCONFFILE);
	push(@array,"/bin/chmod * " . SQUIDCONFFILE);
	push(@array,"/bin/chown * " . SQUIDCONFFILE);
	push(@array,"/bin/mv ".EBox::Config::tmp ."* ". DGDIR . 
		"/dansguardian.conf");
	push(@array,"/bin/chmod * " . DGDIR . "/dansguardian.conf");
	push(@array,"/bin/chown * " . DGDIR . "/dansguardian.conf");
	push(@array,"/bin/mv ".EBox::Config::tmp ."* ". DGDIR . 
		"/dansguardianf1.conf");
	push(@array,"/bin/chmod * " . DGDIR . "/dansguardianf1.conf");
	push(@array,"/bin/chown * " . DGDIR . "/dansguardianf1.conf");
	push(@array,"/bin/mv ".EBox::Config::tmp ."* ". DGDIR . 
		"/bannedsitelist");
	push(@array,"/bin/chmod * " . DGDIR . "/bannedsitelist");
	push(@array,"/bin/chown * " . DGDIR . "/bannedsitelist");
	push(@array,"/bin/mv ".EBox::Config::tmp ."* ". DGDIR . 
		"/exceptionsitelist");
	push(@array,"/bin/chmod * " . DGDIR . "/exceptionsitelist");
	push(@array,"/bin/chown * " . DGDIR . "/exceptionsitelist");
	return @array;
}


# Method: menu 
#
#       Overrides EBox::Module method.
#   
#     
sub menu
{
        my ($self, $root) = @_;
        my $folder = new EBox::Menu::Folder('name' => 'Squid',
                                            'text' => __('HTTP proxy'));

        $folder->add(new EBox::Menu::Item('url' => 'Squid/Index',
                                          'text' => __('General')));
        $folder->add(new EBox::Menu::Item('url' => 'Squid/AllowedDomains',
                                          'text' => __('Allowed domains')));
        $folder->add(new EBox::Menu::Item('url' => 'Squid/BannedDomains',
                                          'text' => __('Banned domains')));
        $folder->add(new EBox::Menu::Item('url' => 'Squid/Policy',
                                          'text' => __('Policy')));
        $root->add($folder);
}

1;

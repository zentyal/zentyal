# Copyright (C) 2005  Warp Networks S.L., DBS Servicios Informaticos S.L.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

package EBox::Squid;
use strict;
use warnings;

use base qw(EBox::GConfModule EBox::FirewallObserver EBox::ObjectsObserver EBox::LogObserver);

use EBox::Service;
use EBox::Objects;
use EBox::Global;
use EBox::Config;
use EBox::Firewall;
use EBox::Validate qw( :all );
use EBox::Exceptions::InvalidData;
use EBox::Exceptions::Internal;
use EBox::Exceptions::DataNotFound;
use EBox::SquidFirewall;
use EBox::SquidLogHelper;
use EBox::SquidOnlyFirewall;
use EBox::Summary::Module;
use EBox::Summary::Value;
use EBox::Summary::Status;
use EBox::Summary::Section;
use EBox::Menu::Item;
use EBox::Menu::Folder;
use EBox::Sudo qw( :all );
use EBox::Gettext;
use EBox;
use Error qw(:try);
use HTML::Mason;


#Module local conf stuff
use constant SQUIDCONFFILE => "@SQUIDCONF@";
use constant MAXDOMAINSIZ => 255; 
use constant SQUIDPORT => '3128';
use constant DGPORT => '3129';
use constant DGDIR => '/etc/dansguardian';


sub _create
{
	my $class = shift;
	my $self  = $class->SUPER::_create(name => 'squid', 
					   domain => 'ebox-squid',
					   @_);
	$self->{logger} = EBox::logger();
	bless ($self, $class);
	return $self;
}

sub domain
{
	return 'ebox-squid';
}

sub isRunning
{
	return EBox::Service::running('squid');
}

sub DGIsRunning
{
	return EBox::Service::running('dansguardian');
}

sub _doDaemon
{
	my $self = shift;
	my $action = undef;

	if ($self->service and $self->isRunning) {
		$action = 'restart';
	} elsif ($self->service) {
		$action = 'start';
	} elsif ($self->isRunning) {
		$action = 'stop';
	} else {
		return;
	}

	EBox::Service::manage('squid', $action);
}

sub _doDGDaemon
{
	my $self = shift;
	my $action = undef;

	if ($self->_dgNeeded and $self->DGIsRunning) {
		$action = 'restart';
	} elsif ($self->_dgNeeded) {
		$action = 'start';
	} elsif ($self->DGIsRunning) {
		$action = 'stop';
	} else {
		return;
	}

	EBox::Service::manage('dansguardian', $action);
}
sub _stopService 
{
	EBox::Service::manage('squid', 'stop');
	EBox::Service::manage('dansguardian', 'stop');
}

# Method: _regenConfig
#
#       Overrides base method. It regenerates the configuration
#       for squid and dansguardian.
#
sub _regenConfig 
{
	my $self = shift;
	$self->_setSquidConf();
	$self->_doDaemon();
	$self->_doDGDaemon();
}

sub _cache_mem 
{
        my $cache_mem = EBox::Config::configkey('cache_mem');
        ($cache_mem) or
                throw EBox::Exceptions::External(__('You must set the '.
                        'cache_mem variable in the ebox configuration file'));
        return $cache_mem;
}

#
# Method: usesObject
#       
#       Implements EBox::ObjectsObserver interface
#
# Parameters:
#
#       object - 
#
sub usesObject # (object)
{
	my ($self, $object) = @_;
	if ($self->isUnfiltered($object) or $self->isBan($object)) {
		return 1;
	}
	return undef;
}

#
# Method: freeObject
#
#       Implements EBox::ObjectsObserver interface
#
# Parameters :
#
#       object -
sub freeObject # (object)
{
	my ($self, $object) = @_;
	(defined($object) && $object ne "") or return;

	my @unfiltered = @{$self->unfiltered};
	my @bans = @{$self->bans};

	if (grep(/^$object$/, @unfiltered)) {
		my @array = ();
		foreach (@unfiltered) {
			($_ ne $object) or next;
			push(@array, $_)
		}
		$self->setUnfiltered(\@array);
	}

	if (grep(/^$object$/, @bans)) {
		my @array = ();
		foreach (@bans) {
			($_ ne $object) or next;
			push(@array, $_)
		}
		$self->setBans(\@array);
	}
}

#
# Method: setUnfiltered
#
#	Sets a list of objects as unfiltered. This means these objects
#	will not pass through any filter, neither dansguardian nor banned sites
#
# Parameters:
#
#	array ref - holding the object names
#
sub setUnfiltered # (\@objects)
{
	my ($self, $args) = @_;
	my $objects = EBox::Global->modInstance('objects');
	$self->unset("unfiltered");
	($args) or return;
	my @bans = @{$self->bans};
	my $bansflag = undef;
	foreach my $obj (@{$args}) {	
		$objects->objectExists($obj) or
			throw EBox::Exceptions::DataNotFound(
				'data' => __("object"), 'value' => $obj);
		if (grep(/^$obj$/, @bans)) {
			@bans = grep(!/^$obj$/, @bans);
			$bansflag = 1;
		}
        }
	$self->set_list("unfiltered", "string", $args);
	$bansflag and $self->setBans(\@bans);
}

#
# Method: filtered
#
#	Returns a list of filtered objects
#
# Parameters:
#
#	array ref - holding the object names
#
sub filtered
{
	my $self = shift;
	my $objects = EBox::Global->modInstance('objects');
	my @no = @{$self->unfiltered};
	push(@no, @{$self->bans});
	my @names = @{$objects->ObjectNames};
	my @filtered = ();
	foreach my $n (@names) {
		unless (grep(/^$n$/, @no)) {
			push(@filtered, $n);
		}
	}
	return \@filtered;
}

# Method: unfiltered
#
#	Returns a list of unfiltered objects
#
# Parameters:
#
#	array ref - holding the object names
#
sub unfiltered
{
	my $self = shift;
	return $self->get_list("unfiltered");
}

# Method: isUnfiltered
#
#	Checks if a given object is set as unfiltered
#
# Parameters:
#
#	object - object name
#
# Returns:
#
#	boolean - true if it's set as unfiltered, otherwise false
sub isUnfiltered # ($object)
{
	my ($self, $object) = @_;
	my $unfiltered = $self->unfiltered();
	foreach (@{$unfiltered}) {
		return 1 if ($_ eq $object);
	}
	return undef;
}

#
# Method: setBans
#
#	Sets the list of banned objects. This objects could not be browse.
# 
# Parameters:
#
#	array ref - holding the objects
#
sub setBans # (\@bans)
{
	my ($self, $args) = @_;
	my $objects = EBox::Global->modInstance('objects');
	$self->unset("bans");
	($args) or return;
	my @unfiltered = @{$self->unfiltered};
	my $unfilteredflag = undef;
	foreach my $obj (@{$args}) {	
		$objects->objectExists($obj) or
			throw EBox::Exceptions::DataNotFound(
				'data' => __("object"), 'value' => $obj);
		if (grep(/^$obj$/, @unfiltered)) {
			@unfiltered = grep(!/^$obj$/, @unfiltered);
			$unfilteredflag = 1;
		}
        }
	$self->set_list("bans", "string", $args);
	$unfilteredflag and $self->setUnfiltered(\@unfiltered);
}

#
# Method: bans
#
#	Returns the list of banned objects.
#
# Returns:
#
#	array ref - holding the objects
#
sub bans
{
	my $self = shift;
	return $self->get_list("bans");
}

# Method: isBan
#
#	Checks if a given object is banned
#
# Parameters:
#
#	object - object name
#
# Returns:
#
#	boolean - true if it's set as banned, otherwise false
sub isBan # ($object)
{
	my ($self, $object) = @_;
	my $bans = $self->bans();
	foreach (@{$bans}) {
		return 1 if ($_ eq $object);
	}
	return undef;
}

# Method: setAuth
#
#       Set authentication
#
# Parameters:
#
#       auth - boolean: the authentication 
sub setAuth # (auth)
{
	my ($self, $auth) = @_;
	($auth and $self->auth) and return;
	(!$auth and !$self->auth) and return;
	$self->set_bool('auth', $auth);
}


# Method: auth
#
#       Return authentication
#
# Returns:
#
#       boolean - 
sub auth
{
	my $self = shift;
	return $self->get_bool('auth');
}

# Method: setService 
#
#       Enable/Disable the proxy service 
#
# Parameters:
#
#       enabled - boolean. True enable, undef disable
#
sub setService # (enabled) 
{
	my ($self, $active) = @_;
	($active and $self->service) and return;
	(!$active and !$self->service) and return;

	if ($active) {
		my $fw = EBox::Global->modInstance('firewall');
		unless ($fw->availablePort('tcp', $self->port)) {
			throw EBox::Exceptions::DataExists(
				'data'  => __('Squid listening port'),
				'value' => $self->port);
		}
		unless ((!$self->_dgNeeded) or 
				$fw->availablePort('tcp', DGPORT)) {
			throw EBox::Exceptions::DataExists(
				'data'  => __('DansGuardian listening port'),
				'value' => DGPORT);
		}
	}
	$self->set_bool('active', $active);
}

# Method: service 
#
#       Returns if the proxy service is enabled  
#
# Returns:
#
#       boolean - true if enabled, otherwise undef   
sub service
{
	my $self = shift;    	
	return $self->get_bool('active');
}

# Method: setTransproxy
#
#      Sets the transparent proxy mode. 
#
# Parameters:
#
#       enabled - boolean. True enable, undef disable
#
sub setTransproxy # (enabled)
{
	my ($self, $trans) = @_;
	($trans and $self->transproxy) and return undef;
	(!$trans and !$self->transproxy) and return undef;
	$self->set_bool('transproxy', $trans);
	return 1;
}

# Method: transproxy 
#
#       Returns if the transparent proxy mode is enabled  
#
# Returns:
#
#       boolean - true if enabled, otherwise undef   
#
sub transproxy
{
	my $self = shift;
	return $self->get_bool('transproxy');
}

# Method: setPort
#
#       Sets the listening port for the proxy
#
# Parameters:
#
#       port - string: port number
#
sub setPort # (port)
{
	my ($self, $port) = @_;
	my $fw = EBox::Global->modInstance('firewall');
	checkPort($port, "listening port");
	my $currentport = $self->port();	
	if ($currentport == $port) {
		return;
	}
	unless ($fw->availablePort('tcp', $port)) {
		throw EBox::Exceptions::DataExists(
					'data'  => __('listening port'),
					'value' => $port);
	}					
	if ($port eq $self->port) {
		return undef;
	}
	$self->set_int("port", $port);
	return 1;
}


# Method: port
#
#       Returns the listening port for the proxy
#
# Returns:
#
#       string - port number
#
sub port
{
	my $self = shift;    	
	return $self->get_int("port");
}

# Method: bannedDomains 
#
#	Returns the list of banned domains.
# 
# Returns::
#
#	array ref - holding the domains
#
sub bannedDomains
{
	my $self = shift;
	return $self->get_list("banned_sites");
}

# Method: bannedDomainExists
#
#	Checks if a banned domain already exists
# 
# Returns:
#
#       boolean - true if exists, otherwise false
#
sub bannedDomainExists # (domain)
{
	my $self = shift;
	my $domain = shift;

	foreach (@{$self->bannedDomains()}) {
		return 1 if ($_ eq $domain);
	}
	return undef;
}

# Method: allowedDomains 
#
#	Returns the list of allowed domains.
# 
# Returns:
#
#	array ref - holding the domains
#
sub allowedDomains
{
	my $self = shift;
	return $self->get_list("allowed_sites");
}

# Method: allowedDomainExists
#
#	Checks if a banned domain already exists
# 
# Returns:
#
#       boolean - true if exists, otherwise false
#
sub allowedDomainExists # (domain)
{
	my $self = shift;
	my $domain = shift;

	foreach (@{$self->allowedDomains()}) {
		return 1 if ($_ eq $domain);
	}
	return undef;
}


#
sub ipBlocked #
{
	my $self = shift;
	return $self->get_bool("block_ip");
}

sub setIpBlocked #
{
	my ($self, $block) = @_;
	if ($block && $self->ipBlocked) {
		return;
	} elsif (!$block && !$self->ipBlocked){
		return;
	}
	$self->set_bool("block_ip", $block);
}

# Method: globalPolicy
#
#	Returns the global policy
# 
# Returns:
#
#       string - allow | deny | filter
#
sub globalPolicy #
{
	my $self = shift;
	return $self->get_string("policy");
}

# Method: setGlobalPolicy
#
#	Sets the global policy. This is the policy that will be used for those
#	objects without an own policy.
# 
# Parameters:
#
#       policy  - allow | deny | filter
#
sub setGlobalPolicy # (policy)
{
	my ($self, $policy) = @_;
	if ($policy ne 'allow' && $policy ne 'deny' && $policy ne 'filter') {
		throw EBox::Exceptions::Internal(
                        __x("Policy '{policy}' is invalid", policy => $policy));
	}
	if ($policy eq $self->globalPolicy) {
		return undef;
	}
	$self->set_string("policy", $policy);
	return 1;
}

# Method: addBannedDomain 
#
#	Add a new banned domain.
# 
# Parameters:
#
#       domain - string: domain to ban
#
sub addBannedDomain # (domain)
{
	my $self = shift;
	my $domain = shift;

	unless (checkDomainName($domain)) {
  		throw EBox::Exceptions::InvalidData(
				'data' => __('domain name'),
	  			'value' => $domain); 
	}
	if ($self->bannedDomainExists($domain)) {
                 throw EBox::Exceptions::DataExists(
		 		'data' => __('domain name'),
                                'value' => "$domain");
	}
	my @list = @{$self->bannedDomains()};
	push @list, $domain;
	$self->set_list("banned_sites", "string", \@list);	
	return 1;
}

# Method: removeBannedDomain 
#
#	Removes a banned domain.
# 
# Parameters:
#
#       domain - string: domain to remove
#
sub removeBannedDomain # (domain)
{
	my ($self, $domain) = @_;

	unless ($self->bannedDomainExists($domain)) {
		 throw EBox::Exceptions::DataNotFound(
		 		'data' => __("domain"), 
				'value' => $domain); 
	}
	
	my @list = @{$self->bannedDomains()};
	@list = grep (!/^$domain$/, @list);
	$self->set_list("banned_sites", "string", \@list);	
	return 1;
}

# Method: addAllowedDomain 
#
#	Add a new allowed domain.
# 
# Parameters:
#
#       domain - string: domain to allow
#
sub addAllowedDomain # (domain)
{
	my $self = shift;
	my $domain = shift;

	unless (checkDomainName($domain)) {
  		throw EBox::Exceptions::InvalidData(
				'data' => __('domain name'),
	  			'value' => $domain); 
	}
	if ($self->allowedDomainExists($domain)) {
                 throw EBox::Exceptions::DataExists(
		 		'data' => __('domain name'),
                                'value' => "$domain");
	}
	my @list = @{$self->allowedDomains()};
	push @list, $domain;
	$self->set_list("allowed_sites", "string", \@list);	
	return 1;
}

# Method: removeAllowedDomain 
#
#	Removes an allowed domain.
# 
# Parameters:
#
#       domain - string: domain to remove
#
sub removeAllowedDomain # (domain)
{
	my ($self, $domain) = @_;

	unless ($self->allowedDomainExists($domain)) {
		 throw EBox::Exceptions::DataNotFound(
		 		'data' => __("domain"), 
				'value' => $domain); 
	}
	
	my @list = @{$self->allowedDomains()};
	@list = grep (!/^$domain$/, @list);
	$self->set_list("allowed_sites", "string", \@list);	
	return 1;
}

# Function: setBanThreshold
#
# 	Sets the weighted phrase value that will cause a page to be banned by 
# 	the  content-based filter.
#
# Parameters:
#
# 	threshold - A positive integer with the desired threshold. A value of 0
# 		    will disable the content filter. Acording to dansguardian
# 		    documentation, recommended values are:
#	 		* 50 for young children
#	 		* 100 for old children
#	 		* 160 for young adults
sub setBanThreshold # (threshold)
{
	my ($self, $thres) = @_;
	unless ($thres =~ /^\d+$/) {
		throw EBox::Exceptions::InvalidData(data=>__('Threshold'),
						value=>$thres);
	}
	my $old_thres = $self->banThreshold;
	($thres ne $old_thres) or return;
	$self->set_int('threshold', $thres);
}

# Function: banThreshold
#
# 	Gets the weighted phrase value that will cause a page to be banned.
#
# Returns:
#
# 	A positive integer with the current ban threshold.
sub banThreshold
{
	my $self = shift;
	return $self->get_int('threshold');
}

sub _dgNeeded
{
	my $self = shift;
	$self->service or return undef;
	$self->ipBlocked and return 1;
	($self->banThreshold > 0) and return 1;
	((scalar(@{$self->bannedDomains}) > 0) and ($self->banThreshold > 0)) and return 1;
	((scalar(@{$self->allowedDomains}) > 0) and ($self->banThreshold > 0)) and return 1;
	return undef;
}

# Function: usesPort
#
#	Implements EBox::FirewallObserver interface
#
sub usesPort # (protocol, port, iface)
{
	my ($self, $protocol, $port, $iface) = @_;
	($protocol eq 'tcp') or return undef;
	# DGPORT is hard-coded, it is reported as used even if
	# the service is disabled.
	($port eq DGPORT) and return 1;
	# the port selected by the user (by default SQUIDPORT) is only reported
	# if the service is enabled
	($self->service) or return undef;
	($port eq $self->port) and return 1;
	return undef;
}

sub _setSquidConf
{
	my $self = shift;
	if ($self->_dgNeeded) {
		$self->_squidAndDG;
	} else {
		$self->_squidOnly;
	}
}

sub _squidOnly
{
	my $self = shift;
	my $ob = EBox::Global->modInstance('objects');
	my $objects;
	my $policy = $self->globalPolicy;
	my $squidpolicy = $policy;
	my $trans = 'no';
	my @exceptions = ();
	($self->transproxy) and $trans = 'yes';

	if ($policy eq 'deny') {
		push(@exceptions, @{$self->filtered});
		push(@exceptions, @{$self->unfiltered});
	} else {
		$squidpolicy = "allow";
		push(@exceptions, @{$self->bans});
	}
	
	foreach my $aux (@exceptions) {
		foreach my $addr (@{$ob->ObjectAddresses($aux)}) {
			$objects .= "acl objects src  $addr\n";
		}
	}

	my @array = ();
	push(@array, 'port'  => $self->port);
	push(@array, 'transparent'  => $trans);
	push(@array, 'policy'  => $squidpolicy);
	push(@array, 'objects' => $objects);
	push(@array, 'memory' => $self->_cache_mem);

	$self->writeConfFile(SQUIDCONFFILE, "squid/squid.conf.mas", \@array);
}

# Function: dansguardianPort 
#
# 	Returns the listening port for dansguardian
#
# Returns:
#
#	string - listening port
sub dansguardianPort
{
	return DGPORT;
}

sub _squidAndDG
{
	my $self = shift;
	my $ob = EBox::Global->modInstance('objects');
	my $objects;
	my $banned = $self->bannedDomains;
	my $allowed = $self->allowedDomains;
	my $policy = $self->globalPolicy;
	my $squidpolicy = $policy;
	my $trans = 'no';
	my $block_ip = 'no';
	my @exceptions = ();
	my $threshold = $self->banThreshold;
	($self->transproxy) and $trans = 'yes';
	($self->ipBlocked) and $block_ip = 'yes';

	if ($policy eq 'allow') {
		push(@exceptions, @{$self->bans});
		push(@exceptions, @{$self->filtered});
	} else {
		$squidpolicy = "deny";
		push(@exceptions, @{$self->unfiltered});
	}

	foreach my $aux (@exceptions) {
		foreach my $addr (@{$ob->ObjectAddresses($aux)}) {
			$objects .= "acl objects src  $addr\n";
		}
	}

	my @writeParam = ();
	push(@writeParam, 'port'  => $self->port);
	push(@writeParam, 'transparent'  => $trans);
	push(@writeParam, 'policy'  => $squidpolicy);
	push(@writeParam, 'objects' => $objects);
	push(@writeParam, 'memory' => $self->_cache_mem);

	$self->writeConfFile(SQUIDCONFFILE, "squid/squid.conf.mas", \@writeParam);

	my $locale = EBox::locale();
	my $lang = 'ukenglish';
	if ($locale =~ /^es_/) {
		$lang = 'arspanish';
	} elsif ($locale =~ /^fr_/) {
		$lang = 'french';
	}

	@writeParam = ();
	# FIXME - get a proper lang name for the current locale
	push(@writeParam, 'port'  => DGPORT);
	push(@writeParam, 'lang'  => $lang);
	push(@writeParam, 'squidport'  => $self->port);
	$self->writeConfFile(DGDIR . "/dansguardian.conf",
				"squid/dansguardian.conf.mas", \@writeParam);

	@writeParam = ();
	push(@writeParam, 'threshold'  => $threshold);
	$self->writeConfFile(DGDIR . "/dansguardianf1.conf",
				"squid/dansguardianf1.conf.mas", \@writeParam);

	@writeParam = ();
	push(@writeParam, 'block_ip'  => $block_ip);
	push(@writeParam, 'domains'  => $banned);
	$self->writeConfFile(DGDIR . "/bannedsitelist",
				"squid/bannedsitelist.mas", \@writeParam);

	@writeParam = ();
	push(@writeParam, 'domains'  => $allowed);
	$self->writeConfFile(DGDIR . "/exceptionsitelist",
				"squid/exceptionsitelist.mas", \@writeParam);
	@writeParam = ();
	push(@writeParam, 'extensions'  => $self->bannedExtensions());
	$self->writeConfFile(DGDIR . "/bannedextensionlist",
				"squid/bannedextensionlist.mas", \@writeParam);
	# Write down the banned mime type list
	@writeParam = ();
	push(@writeParam, 'mimeTypes' => $self->bannedMimeTypes());
	$self->writeConfFile(DGDIR . "/bannedmimetypelist",
			     "squid/bannedmimetypelist.mas", \@writeParam);

}

sub _setList # ($listName, $newList)
{
	my ($self, $listName, $newList) = @_;

	my @list= sort @{$self->get_list($listName)};
	my @newTempList = sort @{$newList};

	my $changed = undef;

	if ($#list == $#newTempList) {
	 	my $i = 0;
		foreach my $val (@newTempList) {
			if ($val ne $list[$i]) {
				$changed = 1;
				last;
			}
			$i++;
		}
	} else {
		$changed = 1;
	}

	$self->set_list($listName, 'string', \@newTempList) if ($changed);
}

# Function: allowedExtensions
#
#	Fetch the allowed extensions
#
# Returns:
#
# 	Array ref - containing the extensions
sub allowedExtensions
{
	my ($self) = @_;

	return $self->get_list('allowed_extensions');
}


# Function: setAllowedExtensions
#
#	Set the allowed extensions
#
# Parameters:
#
# 	Array  - containing the extensions
sub setAllowedExtensions
{
	my ($self, @newallow) = @_;

	$self->_setList('allowed_extensions', \@newallow);

}

# Function: bannedExtensions
#
#	Fetch the banned extensions
#
# Returns:
#
# 	Array ref - containing the extensions
sub bannedExtensions
{
	my ($self) = @_;

	return $self->get_list('banned_extensions');
}

# Function: setBannedExtensions
#
#	Set the banned  extensions
#
# Parameters:
#
# 	Array  - containing the extensions
sub setBannedExtensions
{
	my ($self, @newban) = @_;

	$self->_setList('banned_extensions', \@newban);

}

# Function: hashedExtension
#
#	Fetch the extensions, both allowed and banned
#
# Returns:
#
# 	Array ref of hashes containing:
#
# 		extension => boolean (allowed or not)
#
sub hashedExtensions
{
	my ($self) = @_;

	my %extents;

	foreach my $extension (@{$self->allowedExtensions()}) {
	  $extents{$extension} = 1;
	}

	foreach my $extension (@{$self->bannedExtensions()}) {
	  $extents{$extension} = undef;
	}
	return \%extents;
}

# Function: ianaMimeTypes
#
#	Return the current types established by IANA. 
#       A MIME type follows this syntax: type/subtype
#       The current registrated types are: <http://www.iana.org/assignments/media-types/index.html>
#
# Returns:
#
# 	Array ref - containing this mime types
sub ianaMimeTypes
  {
    my ($self) = @_;

    my $types = ["application",
		 "audio",
		 "example",
		 "image",
		 "message",
		 "model",
		 "multipart",
		 "text",
		 "video",
		 "[Xx]-.*" ];

    return $types;
  }


# Function: allowedMimeTypes
#
#	Fetch the allowed mime type list
#
# Returns:
#
# 	Array ref - containing the mime types
sub allowedMimeTypes
{
	my ($self) = @_;

	return $self->get_list('allowed_mimetype');
}


# Function: setAllowedMimeTypes
#
#	Set the allowed mime type list
#
# Parameters:
#
# 	Array  - containing the mime types
sub setAllowedMimeTypes
{
	my ($self, @newallow) = @_;

	$self->_setList('allowed_mimetype', \@newallow);
}

# Function: bannedMimeTypes
#
#	Fetch the banned mime type list
#
# Returns:
#
# 	Array ref - containing the mime types
sub bannedMimeTypes
{
	my ($self) = @_;

	return $self->get_list('banned_mimetype');
}

# Function: setBannedMimeTypes
#
#	Set the banned mime type list
#
# Parameters:
#
# 	Array  - containing the mime types
sub setBannedMimeTypes
{
	my ($self, @newban) = @_;

	$self->_setList('banned_mimetype', \@newban);
}

# Function: hashedMimeTypes
#
#	Fetch the mime types, both allowed and banned
#
# Returns:
#
# 	Array ref of hashes containing:
#
# 		mimeType => boolean (allowed or not)
#
sub hashedMimeTypes
{
	my ($self) = @_;

	my %extents;
	foreach my $mimeType (@{$self->allowedMimeTypes()}) {
	  $extents{$mimeType} = 1;
	}
	foreach my $mimeType (@{$self->bannedMimeTypes()}) {
	  $extents{$mimeType} = undef;
	}
	return \%extents;
}


sub firewallHelper 
{
	my $self = shift;
	if ($self->service) {
		if ($self->_dgNeeded()) {
			return new EBox::SquidFirewall();
		} else  {
			return new EBox::SquidOnlyFirewall();
		}
	}
	return undef;
}

sub statusSummary
{
	my $self = shift;
	return new EBox::Summary::Status('squid', __('HTTP Proxy'),
					$self->isRunning, $self->service);
}

# Method: summary
#
#       Overrides EBox::Module method.
#   
#     
sub summary
{
	my $self = shift;
	$self->isRunning() or return undef;

	my $item = new EBox::Summary::Module(__("Proxy"));
	my $section = new EBox::Summary::Section();
	my $status;
	$item->add($section);
	
	if ($self->transproxy) {
		$status = __("Enabled");
	} else {
		$status = __("Disabled");
	}
	$section->add(new EBox::Summary::Value(__("Transparent proxy"),$status));
	
	if ($self->globalPolicy eq 'allow') {
		$status = __("Allow");
	} elsif ($self->globalPolicy eq 'deny') {
		$status = __("Deny");
	} elsif ($self->globalPolicy eq 'filter') {
		$status = __("Filter");
	}

	$section->add(new EBox::Summary::Value(__("Global policy"), $status));
	
	$section->add(new EBox::Summary::Value(__("Listening port"), 
					       $self->port));
	return $item;
}



# Method: menu 
#
#       Overrides EBox::Module method.
#
#
sub menu
{
        my ($self, $root) = @_;
        my $folder = new EBox::Menu::Folder('name' => 'Squid',
                                            'text' => __('HTTP proxy'));

        $folder->add(new EBox::Menu::Item('url' => 'Squid/Index',
                                          'text' => __('General')));
        $folder->add(new EBox::Menu::Item('url' => 'Squid/AllowedDomains',
                                          'text' => __('Allowed domains')));
        $folder->add(new EBox::Menu::Item('url' => 'Squid/BannedDomains',
                                          'text' => __('Banned domains')));
	$folder->add(new EBox::Menu::Item('url' => 'Squid/ExtensionsUI',
                                          'text' => __('Extensions filter')));
	$folder->add(new EBox::Menu::Item('url' => 'Squid/MimeTypesUI',
					  'text' => __('MIME Type filter')));
        $folder->add(new EBox::Menu::Item('url' => 'Squid/Policy',
                                          'text' => __('Policy')));
        $root->add($folder);
}

# Impelment LogHelper interface
sub tableInfo {
	my $self = shift;
	my $titles = { 'timestamp' => __('Date'),
			'remotehost' => __('Host'),
			'url'	=> __('URL'),
			'bytes' => __('Bytes'),
			'mimetype' => __('Mime/type'),
			'event' => __('Event')
	};
	my @order = ( 'timestamp', 'remotehost', 'url', 
			'bytes', 'mimetype', 'event');

	my $events = { 'accepted' => __('Accepted'), 
			'denied' => __('Denied'),
			'filtered' => __('Filtered') };
	return {
		'name' => __('HTTP proxy'),
		'index' => 'squid',
		'titles' => $titles,
		'order' => \@order,
		'tablename' => 'access',
		'timecol' => 'timestamp',
		'filter' => ['url', 'remotehost'],
		'events' => $events,
		'eventcol' => 'event'
	};
}

sub logHelper
{
	my $self = shift;

        return (new EBox::SquidLogHelper);
}

1;
